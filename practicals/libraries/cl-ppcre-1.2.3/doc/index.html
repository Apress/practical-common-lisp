<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html> 

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <title>CL-PPCRE - portable Perl-compatible regular expressions for Common Lisp</title>
  <style type="text/css">
  pre { padding:5px; background-color:#e0e0e0 }
  a { text-decoration: none; }
  a.none { border:1px solid white; }
  a.none:hover { border:1px solid white; }
  a { border:1px solid white; }
  a:hover   { border: 1px solid black; } 
  a.noborder { border:0px }
  a.noborder:hover { border:0px }
  </style>
</head>

<body bgcolor=white>

<h2>CL-PPCRE - portable Perl-compatible regular expressions for Common Lisp</h2>

<blockquote>
<br>&nbsp;<br><h3>Abstract</h3>

CL-PPCRE is a portable regular expression library for Common Lisp
which has the following features:

<ul>

<li>It is <b>compatible with Perl</b>. (Well - as far as you can be
compatible with a language defined by its ever-changing
implementation. Currently, as of December 2002, CL-PPCRE is more
compatible with the regex semantics of Perl&nbsp;5.8.0 than, say,
Perl&nbsp;5.6.1 is...:) It even correctly parses and applies <a
href="http://www.oreilly.com/catalog/regex2/">Jeffrey Friedl's</a>
famous 6600-byte long RFC822 address pattern.

<li>It is <b>fast</b>. If compiled with <a
href="http://www.cons.org/cmucl/">CMUCL</a> it <a
href="#performance">outperforms</a> Perl's highly optimized regex engine (written
in C) which to my knowledge is faster than most other regex engines
around. If compiled with <a
href="http://clisp.sourceforge.net/">CLISP</a> it is still comparable
to CLISP's own regex implementation which is also written in
C.

<li>It is <b>portable</b>, i.e. the code aims to be strictly <a
href="http://www.lispworks.com/reference/HyperSpec/Front/index.htm">ANSI-compliant</a>. If
you encounter any deviations this is an error and should be
reported to <a
href="#mail">the mailing list</a>. CL-PPCRE has been
successfully tested with the following Common Lisp implementations:

<ul>

<li><a href="http://www.franz.com/products/allegrocl/">Allegro Common Lisp</a> (6.2 trial on Gentoo Linux 1.1a)
<li><a href="http://clisp.sourceforge.net/">CLISP</a> (2.30 on Gentoo Linux 1.1a and 2.29 on Windows XP pro)
<li><a href="http://www.cons.org/cmucl/">CMUCL</a> (18e on Gentoo Linux 1.1a)
<li><a href="http://www.cormanlisp.com/">Corman Lisp</a> (2.5 on Windows XP pro)
<li><a href="http://ecls.sourceforge.net/">ECL</a> (0.9c on Gentoo Linux 1.1a)
<li><a href="http://www.symbolics.com/">Genera 8.5</a>
<li><a href="http://www.digitool.com/">Macintosh Common Lisp</a> (4.3 demo on MacOS 9.1 - only tested with CL-PPCRE 0.1.x)
<li><a href="http://openmcl.clozure.com/">OpenMCL</a> (0.13.4 on MacOS X 10.2.2 - only tested with CL-PPCRE 0.1.x)
<li><a href="http://sbcl.sourceforge.net/">SBCL</a> (0.8.4 on Gentoo Linux 1.1a)
<li><a href="http://www.scieneer.com/scl/">Scieneer Common Lisp</a> (1.1.1 evaluation on Gentoo Linux 1.1a - only tested with CL-PPCRE 0.1.x)
<li><a href="http://www.lispworks.com/">LispWorks</a> (4.2.7 professional on Gentoo Linux 1.1a and 4.3.6 professional on Windows XP pro)

</ul>

If you succeed in using CL-PPCRE on other platforms please <a
href="#mail">let us know</a>.

<br>
Note that the tests mainly made sure that the package compiled
without errors and that the <a href="#test">test suite</a> - which
compiles about 1,500 regex strings into scanners and applies these to
target strings with the <a href="#scan"><code>SCAN</code></a> function
- yields the expected results. Other functions like <a
href="#split"><code>SPLIT</code></a>, <a
href="#all-matches"><code>ALL-MATCHES</code></a>, <a
href="#regex-replace"><code>REGEX-REPLACE</code></a>, <a
href="#regex-apropos"><code>REGEX-APROPOS</code></a>, or <a
href="#do-scans">the <code>DO</code>-macros</a> have only been tested
on CMUCL and LispWorks which were my main development platforms.

<br>Also, I don't have the time to re-test any implementation with
every new release of CL-PPCRE. <a href="#mail">Let us
know</a> if your implementation is listed above and fails with a
recent version and I'll try to fix it.

<li>It is <b>thread-safe</b>. Although the code uses closures
extensively, no state which dynamically changes during the scanning
process is stored in the lexical environments of the closures, so it
should be safe to use CL-PPCRE in a multi-threaded program. Tests with
LispWorks and Scieneer Common Lisp seem to confirm this.

<li>It comes with <b>convenient features</b> like a <a
href="#split"><code>SPLIT</code></a> function, a couple of <a
href="#do-scans"><code>DO</code>-like loop constructs</a>, and a <a
href="#regex-apropos"><code>regex-based APROPOS feature</code></a>
similar to the one found in <a
href="http://www.gnu.org/software/emacs/emacs.html">Emacs</a>.

<li>In addition to specifying regular expressions as strings like in
Perl you can also use <a
href="#create-scanner2"><b>S-expressions</b></a> which obviously is
more Lisp-y.

<li>Is it is fully <b>documented</b> so I might have a chance to
understand my own code in about six months... :)

<li>It comes with a <a
href="http://www.opensource.org/licenses/bsd-license.php"><b>BSD-style
license</b></a> so you can basically do with it whatever you want.

</ul>

CL-PPCRE has been used successfully in various applications like <a
href="http://nostoc.stanford.edu/Docs/">BioLingua</a>, <a
href="http://www.hpc.unm.edu/~download/LoGS/">LoGS</a>, or <a
href="http://weitz.de/regex-coach/">The Regex Coach</a>.

<p>
<font color=red>Download shortcut:</font> <a href="http://weitz.de/files/cl-ppcre.tar.gz">http://weitz.de/files/cl-ppcre.tar.gz</a>.

</blockquote>

<br>&nbsp;<br><h3><a class=none name="contents">Contents</a></h3>
<ol>
  <li><a href="#install">Download and installation</a>
  <li><a href="#mail">Support and mailing lists</a>
  <li><a href="#dict">The CL-PPCRE dictionary</a>
  <ol>
    <li><a href="#create-scanner"><code>create-scanner</code></a> (for Perl regex strings)
    <li><a href="#create-scanner2"><code>create-scanner</code></a> (for parse trees)
    <li><a href="#parse-tree-synonym"><code>parse-tree-synonym</code></a>
    <li><a href="#define-parse-tree-synonym"><code>define-parse-tree-synonym</code></a>
    <li><a href="#scan"><code>scan</code></a>
    <li><a href="#scan-to-strings"><code>scan-to-strings</code></a>
    <li><a href="#register-groups-bind"><code>register-groups-bind</code></a>
    <li><a href="#do-scans"><code>do-scans</code></a>
    <li><a href="#do-matches"><code>do-matches</code></a>
    <li><a href="#do-matches-as-strings"><code>do-matches-as-strings</code></a>
    <li><a href="#do-register-groups"><code>do-register-groups</code></a>
    <li><a href="#all-matches"><code>all-matches</code></a>
    <li><a href="#all-matches-as-strings"><code>all-matches-as-strings</code></a>
    <li><a href="#split"><code>split</code></a>
    <li><a href="#regex-replace"><code>regex-replace</code></a>
    <li><a href="#regex-replace-all"><code>regex-replace-all</code></a>
    <li><a href="#regex-apropos"><code>regex-apropos</code></a>
    <li><a href="#regex-apropos-list"><code>regex-apropos-list</code></a>
    <li><a href="#regex-char-code-limit"><code>*regex-char-code-limit*</code></a>
    <li><a href="#use-bmh-matchers"><code>*use-bmh-matchers*</code></a>
    <li><a href="#*allow-quoting*"><code>*allow-quoting*</code></a>
    <li><a href="#quote-meta-chars"><code>quote-meta-chars</code></a>
    <li><a href="#ppcre-error"><code>ppcre-error</code></a>
    <li><a href="#ppcre-invocation-error"><code>ppcre-invocation-error</code></a>
    <li><a href="#ppcre-syntax-error"><code>ppcre-syntax-error</code></a>
    <li><a href="#ppcre-syntax-error-string"><code>ppcre-syntax-error-string</code></a>
    <li><a href="#ppcre-syntax-error-pos"><code>ppcre-syntax-error-pos</code></a>
  </ol>
  <li><a href="#filters">Filters</a>
  <li><a href="#test">Testing CL-PPCRE</a>
  <li><a href="#perl">Compatibility with Perl</a>
    <ol>
      <li><a href="#empty">Empty strings instead of <code>undef</code> in <code>$1</code>, <code>$2</code>, etc.</a>
      <li><a href="#scope">Strange scoping of embedded modifiers</a>
      <li><a href="#inconsistent">Inconsistent capturing of <code>$1</code>, <code>$2</code>, etc.</a>
      <li><a href="#lookaround">Captured groups not available outside of look-aheads and look-behinds</a>
      <li><a href="#order">Alternations don't always work from left to right</a>
      <li><a href="#mac"><code>&quot;\r&quot;</code> doesn't work with MCL</a>
      <li><a href="#alpha">What about <code>&quot;\w&quot;</code>?</a>
    </ol>
  <li><a href="#performance">Performance</a>
    <ol>
      <li><a href="#bench">Benchmarking</a>
      <li><a href="#other">Other performance issues</a>
    </ol>
  <li><a href="#bugs">Bugs and problems</a>
  <ol>
    <li><a href="#stack">Stack overflow</a>
    <li><a href="#quote"><code>&quot;\Q&quot;</code> doesn't work, or does it?</a>
    <li><a href="#backslash">Backslashes may confuse you...</a>
  </ol>
  <li><a href="#remarks">Remarks</a>
  <li><a href="#allegro">AllegroCL compatibility mode</a>
  <li><a href="#ack">Acknowledgements</a>
</ol>

<br>&nbsp;<br><h3><a name="install" class=none>Download and installation</a></h3>

CL-PPCRE together with this documentation can be downloaded from <a
href="http://weitz.de/files/cl-ppcre.tar.gz">http://weitz.de/files/cl-ppcre.tar.gz</a>. The
current version is 1.2.3 - older versions are
available for download through URLs like
<code>http://weitz.de/files/cl-ppcre-&lt;version&gt;.tar.gz</code> (or ending in <code>.tgz</code> for 0.9.0 and older.). A <a
href="CHANGELOG">CHANGELOG</a> is available.
<p>
If you're on <a href="http://www.debian.org/">Debian</a> you should
probably use the <a
href="http://packages.debian.org/cgi-bin/search_packages.pl?keywords=cl-ppcre&searchon=names&version=all&release=all">cl-ppcre
Debian package</a> which is available thanks to <a href="http://b9.com/">Kevin
Rosenberg</a>. There's also a port
for <a href="http://www.cliki.net/gentoo">Gentoo Linux</a> thanks to Matthew Kennedy and a <a href="http://www.freebsd.org/cgi/url.cgi?ports/textproc/cl-ppcre/pkg-descr">FreeBSD port</a> thanks to Henrik Motakef.
Installation via <a
href="http://www.cliki.net/asdf-install">asdf-install</a> should as well
be possible.
<p>
CL-PPCRE comes with simple system definitions for <a
href="http://www.cliki.net/mk-defsystem">MK:DEFSYSTEM</a> and <a
href="http://www.cliki.net/asdf">asdf</a> so you can either adapt it
to your needs or just unpack the archive and from within the CL-PPCRE
directory start your Lisp image and evaluate the form
<code>(mk:compile-system &quot;cl-ppcre&quot;)</code> (or the
equivalent one for asdf) which should compile and load the whole
system.
<p>
If for some reason you don't want to use MK:DEFSYSTEM or asdf you
can just <code>LOAD</code> the file <code>load.lisp</code> or you
can also get away with something like this:

<pre>
(loop for name in '("packages" "specials" "util" "errors" "lexer"
                    "parser" "regex-class" "convert" "optimize"
                    "closures" "repetition-closures" "scanner" "api")
      do (compile-file (make-pathname :name name
                                      :type "lisp"))
         (load name))
</pre>

Note that on CL implementations which use the Python compiler
(i.e. CMUCL, SBCL, SCL) you can concatenate the compiled object files
to create one single object file which you can load afterwards:

<pre>
cat {packages,specials,util,errors,lexer,parser,regex-class,convert,optimize,closures,repetition-closures,scanner,api}.x86f > cl-ppcre.x86f
</pre>

(Replace &quot;.<code>x86f</code>&quot; with the correct suffix for
your platform.)
<p>
Note that there is <em>no</em> public CVS repository for CL-PPCRE - the repository at <a href="http://common-lisp.net/">common-lisp.net</a> is out of date and not in sync with the (current) version distributed from <a href="http://weitz.de/">weitz.de</a>.


<br>&nbsp;<br><h3><a name="mail" class=none>Support and mailing lists</a></h3>

For questions, bug reports, feature requests, improvements, or patches
please use the <a
href="http://common-lisp.net/mailman/listinfo/cl-ppcre-devel">cl-ppcre-devel
mailing list</a>. If you want to be notified about future releases
subscribe to the <a
href="http://common-lisp.net/mailman/listinfo/cl-ppcre-announce">cl-ppcre-announce
mailing list</a>. These mailing lists were made available thanks to
the services of <a href="http://common-lisp.net/">common-lisp.net</a>.

<br>&nbsp;<br><h3><a class=none name="dict">The CL-PPCRE dictionary</a></h3>

CL-PPCRE exports the following symbols:

<p><br>[Method]
<br><a class=none name="create-scanner"><b>create-scanner</b> <i>(string string)<tt>&amp;key</tt> case-insensitive-mode multi-line-mode single-line-mode extended-mode destructive</i> =&gt; <i>scanner</i></a>

<blockquote><br> Accepts a string which is a regular expression in
Perl syntax and returns a closure which will scan strings for this
regular expression. The mode keyboard arguments are equivalent to the
<code>&quot;imsx&quot;</code> modifiers in Perl. The
<code>destructive</code> keyword will be ignored.
<p>
The function accepts most of the regex syntax of Perl 5 as described
in <a
href="http://www.perldoc.com/perl5.8.0/pod/perlre.html"><code>man
perlre</code></a> including extended features like non-greedy
repetitions, positive and negative look-ahead and look-behind
assertions, &quot;standalone&quot; subexpressions, and conditional
subpatterns. The following Perl features are (currently) <b>not</b>
supported:

<ul>

<li><code>(?{ code })</code> and <code>(??{ code })</code> because
they obviously don't make sense in Lisp.

<li><code>\N{name}</code> (named characters), <code>\x{263a}</code>
(wide hex characters), <code>\l</code>, <code>\u</code>,
<code>\L</code>, and <code>\U</code>
because they're actually not part of Perl's regex syntax and
(honestly) because I was too lazy - but see <a href="http://weitz.de/cl-interpol/">CL-INTERPOL</a>.

<li><code>\pP</code> and <code>\PP</code> (named properties),
<code>\X</code> (extended Unicode), and <code>\C</code> (single
character). But you can of course use all characters
supported by your CL implementation.

<li>Posix character classes like <code>[[:alpha]]</code>. I
<em>might</em> add this in the future.

<li><code>\G</code> for Perl's <code>pos()</code> because we don't have it.

</ul>

Note, however, that <code>\t</code>, <code>\n</code>, <code>\r</code>,
<code>\f</code>, <code>\a</code>, <code>\e</code>, <code>\033</code>
(octal character codes), <code>\x1B</code> (hexadecimal character
codes), <code>\c[</code> (control characters), <code>\w</code>,
<code>\W</code>, <code>\s</code>, <code>\S</code>, <code>\d</code>,
<code>\D</code>, <code>\b</code>, <code>\B</code>, <code>\A</code>,
<code>\Z</code>, and <code>\z</code> <b>are</b> supported.
<p>
Since version 0.6.0 CL-PPCRE also supports Perl's <code>\Q</code> and <code>\E</code> - see <a
href="#*allow-quoting*"><code>*ALLOW-QUOTING*</code></a> below. Make sure you also read <a href="#quote">the relevant section</a> in &quot;<a href="#bugs">Bugs and problems</a>.&quot;
<p>
The keyword arguments are just for your
convenience. You can always use embedded modifiers like
<code>&quot;(?i-s)&quot;</code> instead.</blockquote>

<p><br>[Method]
<br><a class=none name="create-scanner"><b>create-scanner</b> <i>(function function)<tt>&amp;key</tt> case-insensitive-mode multi-line-mode single-line-mode extended-mode destructive</i> =&gt; <i>scanner</i></a>
<blockquote><br>
In this case <code><i>function</i></code> should be a scanner returned by another invocation of <code>CREATE-SCANNER</code>. It will be returned as is.
</blockquote>

<p><br>[Method]
<br><a class=none name="create-scanner2"><b>create-scanner</b> <i>(parse-tree t)<tt>&amp;key</tt> case-insensitive-mode multi-line-mode single-line-mode extended-mode destructive</i> =&gt; <i>scanner</i></a>
<blockquote><br>
This is similar to <a
href="#create-scanner"><code>CREATE-SCANNER</code></a> for regex strings above but
accepts a <em>parse tree</em> as its first argument. A parse tree is an S-expression
conforming to the following syntax:

<ul>

<li>Every string and character is a parse tree and is treated
<em>literally</em> as a part of the regular expression,
i.e. parentheses, brackets, asterisks and such aren't special.

<li>The symbol <code>:VOID</code> is equivalent to the empty string.

<li>The symbol <code>:EVERYTHING</code> is equivalent to Perl's dot,
i.e it matches everything (except maybe a newline character depending
on the mode).

<li>The symbols <code>:WORD-BOUNDARY</code> and
<code>:NON-WORD-BOUNDARY</code> are equivalent to Perl's
<code>&quot;\b&quot;</code> and <code>&quot;\B&quot;</code>.

<li>The symbols <code>:DIGIT-CLASS</code>,
<code>:NON-DIGIT-CLASS</code>, <code>:WORD-CHAR-CLASS</code>,
<code>:NON-WORD-CHAR-CLASS</code>,
<code>:WHITESPACE-CHAR-CLASS</code>, and
<code>:NON-WHITESPACE-CHAR-CLASS</code> are equivalent to Perl's
<em>special character classes</em> <code>&quot;\d&quot;</code>,
<code>&quot;\D&quot;</code>, <code>&quot;\w&quot;</code>,
<code>&quot;\W&quot;</code>, <code>&quot;\s&quot;</code>, and
<code>&quot;\S&quot;</code> respectively.

<li>The symbols <code>:START-ANCHOR</code>, <code>:END-ANCHOR</code>,
<code>:MODELESS-START-ANCHOR</code>,
<code>:MODELESS-END-ANCHOR</code>, and
<code>:MODELESS-END-ANCHOR-NO-NEWLINE</code> are equivalent to Perl's
<code>&quot;^&quot;</code>, <code>&quot;$&quot;</code>,
<code>&quot;\A&quot;</code>, <code>&quot;\Z&quot;</code>, and
<code>&quot;\z&quot;</code> respectively.

<li>The symbols <code>:CASE-INSENSITIVE-P</code>,
<code>:CASE-SENSITIVE-P</code>, <code>:MULTI-LINE-MODE-P</code>,
<code>:NOT-MULTI-LINE-MODE-P</code>, <code>:SINGLE-LINE-MODE-P</code>,
and <code>:NOT-SINGLE-LINE-MODE-P</code> are equivalent to Perl's
<em>embedded modifiers</em> <code>&quot;(?i)&quot;</code>,
<code>&quot;(?-i)&quot;</code>, <code>&quot;(?m)&quot;</code>,
<code>&quot;(?-m)&quot;</code>, <code>&quot;(?s)&quot;</code>, and
<code>&quot;(?-s)&quot;</code>. As usual, changes applied to modes are
kept local to the innermost enclosing grouping or clustering
construct.

</li><li>All other symbols will signal an error of type <a
href="#ppcre-syntax-error"><code>PPCRE-SYNTAX-ERROR</code></a>
<em>unless</em> they are defined to be <a
href="#parse-tree-synonym"><em>parse tree synonyms</em></a>.

<li><code>(:FLAGS {&lt;modifier&gt;}*)</code> where
<code>&lt;modifier&gt;</code> is one of the modifier symbols from
above is used to group modifier symbols. The modifiers are applied
from left to right. (This construct is obviously redundant. It is only
there because it's used by the parser.)

<li><code>(:SEQUENCE {&lt;<i>parse-tree</i>&gt;}*)</code> means a
sequence of parse trees, i.e. the parse trees must match one after
another. Example: <code>(:SEQUENCE #\f #\o #\o)</code> is equivalent
to the parse tree <code>&quot;foo&quot;</code>.

<li><code>(:GROUP {&lt;<i>parse-tree</i>&gt;}*)</code> is like
<code>:SEQUENCE</code> but changes applied to modifier flags (see
above) are kept local to the parse trees enclosed by this
construct. Think of it as the S-expression variant of Perl's
<code>&quot;(?:&lt;<i>pattern</i>&gt;)&quot;</code> construct.

<li><code>(:ALTERNATION {&lt;<i>parse-tree</i>&gt;}*)</code> means an
alternation of parse trees, i.e. one of the parse trees must
match. Example: <code>(:ALTERNATION #\b #\a #\z)</code> is equivalent
to the Perl regex string <code>&quot;b|a|z&quot;</code>.

<li><code>(:BRANCH &lt;<i>test</i>&gt;
&lt;<i>parse-tree</i>&gt;)</code> is for conditional regular
expressions. <code>&lt;<i>test</i>&gt;</code> is either a number which
stands for a register or a parse tree which is a look-ahead or
look-behind assertion. See the entry for
<code>(?(&lt;<i>condition</i>&gt;)&lt;<i>yes-pattern</i>&gt;|&lt;<i>no-pattern</i>&gt;)</code>
in <a
href="http://www.perldoc.com/perl5.8.0/pod/perlre.html#Extended-Patterns"><code>man
perlre</code></a> for the semantics of this construct. If
<code>&lt;<i>parse-tree</i>&gt;</code> is an alternation is
<em>must</em> enclose exactly one or two parse trees where the second
one (if present) will be treated as the &quot;no-pattern&quot; - in
all other cases <code>&lt;<i>parse-tree</i>&gt;</code> will be treated
as the &quot;yes-pattern&quot;.

<li><code>(:POSITIVE-LOOKAHEAD|:NEGATIVE-LOOKAHEAD|:POSITIVE-LOOKBEHIND|:NEGATIVE-LOOKBEHIND
&lt;<i>parse-tree</i>&gt;)</code> should be pretty obvious...

<li><code>(:GREEDY-REPETITION|:NON-GREEDY-REPETITION
&lt;<i>min</i>&gt; &lt;<i>max</i>&gt;
&lt;<i>parse-tree</i>&gt;)</code> where
<code>&lt;<i>min</i>&gt;</code> is a non-negative integer and
<code>&lt;<i>max</i>&gt;</code> is either a non-negative integer not
smaller than <code>&lt;<i>min</i>&gt;</code> or <code>NIL</code> will
result in a regular expression which tries to match
<code>&lt;<i>parse-tree</i>&gt;</code> at least
<code>&lt;<i>min</i>&gt;</code> times and at most
<code>&lt;<i>max</i>&gt;</code> times (or as often as possible if
<code>&lt;<i>max</i>&gt;</code> is <code>NIL</code>). So, e.g.,
<code>(:NON-GREEDY-REPETITION 0 1 &quot;ab&quot;)</code> is equivalent
to the Perl regex string <code>&quot;(?:ab)??&quot;</code>.

<li><code>(:STANDALONE &lt;<i>parse-tree</i>&gt;)</code> is an
&quot;independent&quot; subexpression, i.e. <code>(:STANDALONE
&quot;bar&quot;)</code> is equivalent to the Perl regex string
<code>&quot;(?>bar)&quot;</code>.

<li><code>(:REGISTER &lt;<i>parse-tree</i>&gt;)</code> is a capturing
register group. As usual, registers are counted from left to right
beginning with 1.

<li><code>(:BACK-REFERENCE &lt;<i>number</i>&gt;)</code> where
<code>&lt;<i>number</i>&gt;</code> is a positive integer is a back-reference to a
register group.

<li><a class=none name="filterdef"><code>(:FILTER &lt;<i>function</i>&gt; <tt>&amp;optional</tt>
&lt;<i>length</i>&gt;)</code></a> where
<code>&lt;<i>function</i>&gt;</code> is a <a
href="http://www.lispworks.com/reference/HyperSpec/Body/26_glo_f.htm#function_designator">function
designator</a> and <code>&lt;<i>length</i>&gt;</code> is a
non-negative integer or <code>NIL</code> is a user-defined <a
href="#filters">filter</a>.

<li><code>(:CHAR-CLASS|:INVERTED-CHAR-CLASS
{&lt;<i>item</i>&gt;}*)</code> where <code>&lt;<i>item</i>&gt;</code>
is either a character, a <em>character range</em>, or a symbol for a
special character class (see above) will be translated into a (one
character wide) character class. A <em>character range</em> looks like
<code>(:RANGE &lt;<i>char1</i>&gt; &lt;<i>char2</i>&gt;)</code> where
<code>&lt;<i>char1</i>&gt;</code> and
<code>&lt;<i>char2</i>&gt;</code> are characters such that
<code>(CHAR&lt;= &lt;<i>char1</i>&gt; &lt;<i>char2</i>&gt;)</code> is
true. Example: <code>(:INVERTED-CHAR-CLASS #\a (:RANGE #\D #\G)
:DIGIT-CLASS)</code> is equivalent to the Perl regex string
<code>&quot;[^aD-G\d]&quot;</code>.

</ul>

Because <code>CREATE-SCANNER</code> is defined as a generic function
which dispatches on its first argument there's a certain ambiguity:
Although strings are valid parse trees they will be interpreted as
Perl regex strings when given to <code>CREATE-SCANNER</code>. To
circumvent this you can always use the equivalent parse tree <code>(:GROUP
&lt;<i>string</i>&gt;)</code> instead.
<p>
Note that <code>CREATE-SCANNER</code> doesn't always check
for the well-formedness of its first argument, i.e. you are expected
to provide <em>correct</em> parse trees.

<p>
The usage of the keyword argument <code>extended-mode</code> obviously
doesn't make sense if <code>CREATE-SCANNER</code> is applied to parse
trees and will signal an error.
<p>
If <code>destructive</code> is not <code>NIL</code> (the default is
<code>NIL</code>) the function is allowed to destructively modify
<code><i>parse-tree</i></code> while creating the scanner.
<p>
If you want to find out how parse trees are related to Perl regex
strings you should play around with
<code>CL-PPCRE::PARSE-STRING</code> - a function which converts Perl
regex strings to parse trees. Here are some examples:

<pre>
* (cl-ppcre::parse-string "(ab)*")
(:GREEDY-REPETITION 0 NIL (:REGISTER "ab"))

* (cl-ppcre::parse-string "(a(b))")
(:REGISTER (:SEQUENCE #\a (:REGISTER #\b)))

* (cl-ppcre::parse-string "(?:abc){3,5}")
(:GREEDY-REPETITION 3 5 (:GROUP "abc"))
<font color=orange>;; (:GREEDY-REPETITION 3 5 "abc") would also be OK</font>

* (cl-ppcre::parse-string "a(?i)b(?-i)c")
(:SEQUENCE #\a
 (:SEQUENCE (:FLAGS :CASE-INSENSITIVE-P)
  (:SEQUENCE #\b (:SEQUENCE (:FLAGS :CASE-SENSITIVE-P) #\c))))
<font color=orange>;; same as (:SEQUENCE #\a :CASE-INSENSITIVE-P #\b :CASE-SENSITIVE-P #\c)</font>

* (cl-ppcre::parse-string "(?=a)b")
(:SEQUENCE (:POSITIVE-LOOKAHEAD #\a) #\b)
</pre></blockquote>

<p><br>[Accessor]
<br><a class="none" name="parse-tree-synonym"><b>parse-tree-synonym</b> <i>symbol</i> =&gt; <i>parse-tree</i>
<br><tt>(setf (</tt><b>parse-tree-synonym</b> <i>symbol</i>) <i>new-parse-tree</i><tt>)</tt></a>

</p><blockquote><br>
Any symbol (unless it's a keyword with a special meaning in parse
trees) can be made a "synonym", i.e. an abbreviation, for another parse
tree by this accessor. <code>PARSE-TREE-SYNONYM</code> returns <code>NIL</code> if <code><i>symbol</i></code> isn't a synonym yet.
<p>
Here's an example:

</p><pre>* (cl-ppcre::parse-string "a*b+")
(:SEQUENCE (:GREEDY-REPETITION 0 NIL #\a) (:GREEDY-REPETITION 1 NIL #\b))

* (defun my-repetition (char min)
    `(:greedy-repetition ,min nil ,char))
MY-REPETITION

* (setf (parse-tree-synonym 'a*) (my-repetition #\a 0))
(:GREEDY-REPETITION 0 NIL #\a)

* (setf (parse-tree-synonym 'b+) (my-repetition #\b 1))
(:GREEDY-REPETITION 1 NIL #\b)

* (let ((scanner (create-scanner '(:sequence a* b+))))
    (dolist (string '("ab" "b" "aab" "a" "x"))
      (print (scan scanner string)))
    (values))
0
0
0
NIL
NIL

* (parse-tree-synonym 'a*)
(:GREEDY-REPETITION 0 NIL #\a)

* (parse-tree-synonym 'a+)
NIL
</pre></blockquote>

<p><br>[Macro]
<br><a class="none" name="define-parse-tree-synonym"><b>define-parse-tree-synonym</b> <i>name parse-tree</i> =&gt; <i>parse-tree</i></a>

</p><blockquote><br>
This is a convenience macro for parse tree synonyms defined as

<pre>(defmacro define-parse-tree-synonym (name parse-tree)
  `(eval-when (:compile-toplevel :load-toplevel :execute)
     (setf (parse-tree-synonym ',name) ',parse-tree)))
</pre>

so you can write code like this:

<pre>
(define-parse-tree-synonym a-z
  (:char-class (:range #\a #\z) (:range #\a #\z)))

(define-parse-tree-synonym a-z*
  (:greedy-repetition 0 nil a-z))

(defun ascii-char-tester (string)
  (scan '(:sequence :start-anchor a-z* :end-anchor)
        string))
</pre></blockquote>

<p><br>
<b>For the rest of this section </b><code><i>regex</i></code><b> can
always be a string (which is interpreted as a Perl regular
expression), a parse tree, or a scanner created by
</b><code>CREATE-SCANNER</code><b>. The
</b><code><i>start</i></code><b> and </b><code><i>end</i></code><b>
keyword parameters are always used as in </b><a
href="#scan"><code>SCAN</code></a><b>.</b>




<p><br>[Standard Generic Function]
<br><a class=none name="scan"><b>scan</b> <i>regex target-string <tt>&amp;key</tt> start end</i> =&gt; <i>match-start, match-end, reg-starts, reg-ends</i></a>

<blockquote><br>
Searches the string <code><i>target-string</i></code> from
<code><i>start</i></code> (which defaults to 0) to
<code><i>end</i></code> (which default to the length of
<code><i>target-string</i></code>) and tries to match
<code><i>regex</i></code>. On success returns four values - the start
of the match, the end of the match, and two arrays denoting the
beginnings and ends of register matches. On failure returns
<code>NIL</code>.  <code><i>target-string</i></code> will be coerced to a
simple string if it isn't one already.
<p>
<code>SCAN</code> acts as if the part of
<code><i>target-string</i></code> between <code><i>start</i></code>
and <code><i>end</i></code> were a standalone string, i.e. look-aheads
and look-behinds can't look beyond these boundaries.
<p>
Examples:
<pre>
* (cl-ppcre:scan "(a)*b" "xaaabd")
1
5
#(3)
#(4)

* (cl-ppcre:scan "(a)*b" "xaaabd" :start 1)
1
5
#(3)
#(4)

* (cl-ppcre:scan "(a)*b" "xaaabd" :start 2)
2
5
#(3)
#(4)

* (cl-ppcre:scan "(a)*b" "xaaabd" :end 4)
NIL

* (cl-ppcre:scan '(:GREEDY-REPETITION 0 NIL #\b) "bbbc")
0
3
#()
#()

* (cl-ppcre:scan '(:GREEDY-REPETITION 4 6 #\b) "bbbc")
NIL

* (let ((s (cl-ppcre:create-scanner "(([a-c])+)x")))
    (cl-ppcre:scan s "abcxy"))
0
4
#(0 2)
#(3 3)
</pre></blockquote>



<p><br>[Function]
<br><a class=none name="scan-to-strings"><b>scan-to-strings</b> <i>regex target-string <tt>&amp;key</tt> start end sharedp</i> =&gt; <i>match, regs</i></a>

<blockquote><br>
Like <a href="#scan"><code>SCAN</code></a> but returns substrings of
<code><i>target-string</i></code> instead of positions, i.e. this
function returns two values on success: the whole match as a string
plus an array of substrings (or <code>NIL</code>s) corresponding to
the matched registers. If <code><i>sharedp</i></code> is true, the substrings may share structure with
<code><i>target-string</i></code>.
<p>
Examples:
<pre>
* (cl-ppcre:scan-to-strings "[^b]*b" "aaabd")
"aaab"
#()

* (cl-ppcre:scan-to-strings "([^b])*b" "aaabd")
"aaab"
#("a")

* (cl-ppcre:scan-to-strings "(([^b])*)b" "aaabd")
"aaab"
#("aaa" "a")
</pre></blockquote>


<p><br>[Macro]
<br><a class=none name="register-groups-bind"><b>register-groups-bind</b> <i>var-list (regex target-string <tt>&amp;key</tt> start end sharedp) declaration* statement*</i> =&gt; <i>result*</i></a>

<blockquote><br>
Evaluates <code><i>statement*</i></code> with the variables in <code><i>var-list</i></code> bound to the
corresponding register groups after <code><i>target-string</i></code> has been matched
against <code><i>regex</i></code>, i.e. each variable is either
bound to a string or to <code>NIL</code>.
As a shortcut, the elements of <code><i>var-list</i></code> can also be lists of the form <code>(FN&nbsp;VAR)</code> where <code>VAR</code> is the variable symbol
and <code>FN</code> is a <a
href="http://www.lispworks.com/reference/HyperSpec/Body/26_glo_f.htm#function_designator">function
designator</a> (which is evaluated) denoting a function which is to be applied to the string before the result is bound to <code>VAR</code>.
To make this even more convenient the form <code>(FN&nbsp;VAR1&nbsp;...VARn)</code> can be used as an abbreviation for
<code>(FN&nbsp;VAR1)&nbsp;...&nbsp;(FN&nbsp;VARn).
<p>
If there is no match, the <code><i>statement*</i></code> forms are <em>not</em>
executed. For each element of
<code><i>var-list</i></code> which is <code>NIL</code> there's no binding to the corresponding register
group. The number of variables in <code><i>var-list</i></code> must not be greater than
the number of register groups. If <code><i>sharedp</i></code> is true, the substrings may
share structure with <code><i>target-string</i></code>.
<p>Examples:
<pre>
* (register-groups-bind (first second third fourth)
      (&quot;((a)|(b)|(c))+&quot; &quot;abababc&quot; :sharedp t)
    (list first second third fourth))
(&quot;c&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot;)

* (register-groups-bind (nil second third fourth)
      <font color=orange>;; note that we don't bind the first and fifth register group</font>
      (&quot;((a)|(b)|(c))()+&quot; &quot;abababc&quot; :start 6)
    (list second third fourth))
(NIL NIL &quot;c&quot;)

* (register-groups-bind (first)
      (&quot;(a|b)+&quot; &quot;accc&quot; :start 1)
    (format t &quot;This will not be printed: ~A&quot; first))
NIL

* (register-groups-bind (fname lname (#'parse-integer date month year))
      (&quot;(\\w+)\\s+(\\w+)\\s+(\\d{1,2})\\.(\\d{1,2})\\.(\\d{4})&quot; &quot;Frank Zappa 21.12.1940&quot;)
    (list fname lname (encode-universal-time 0 0 0 date month year)))
("Frank" "Zappa" 1292882400)
</pre>
</blockquote>

<p><br>[Macro]
<br><a class=none name="do-scans"><b>do-scans</b> <i>(match-start match-end reg-starts reg-ends regex target-string <tt>&amp;optional</tt> result-form <tt>&amp;key</tt> start end) declaration* statement*</i> =&gt; <i>result*</i></a>

<blockquote><br>
A macro which iterates over <code><i>target-string</i></code> and
tries to match <code><i>regex</i></code> as often as possible
evaluating <code><i>statement*</i></code> with
<code><i>match-start</i></code>, <code><i>match-end</i></code>,
<code><i>reg-starts</i></code>, and <code><i>reg-ends</i></code> bound
to the four return values of each match (see <a
href="#scan"><code>SCAN</code></a>) in turn. After the last match,
returns <code><i>result-form</i></code> if provided or
<code>NIL</code> otherwise. An implicit block named <code>NIL</code>
surrounds <code>DO-SCANS</code>; <code>RETURN</code> may be used to
terminate the loop immediately. If <code><i>regex</i></code> matches
an empty string the scan is continued one position behind this match.
<p>
This is the most general macro to iterate over all matches in a target
string. See the source code of <a
href="#do-matches"><code>DO-MATCHES</code></a>, <a
href="#all-matches"><code>ALL-MATCHES</code></a>, <a
href="#split"><code>SPLIT</code></a>, or <a
href="#regex-replace-all"><code>REGEX-REPLACE-ALL</code></a> for examples of its
usage.</blockquote>




<p><br>[Macro]
<br><a class=none name="do-matches"><b>do-matches</b> <i>(match-start match-end regex target-string <tt>&amp;optional</tt> result-form <tt>&amp;key</tt> start end) declaration* statement*</i> =&gt; <i>result*</i></a>

<blockquote><br>
Like <a href="#do-scans"><code>DO-SCANS</code></a> but doesn't bind
variables to the register arrays.
<p>Example:
<pre>
* (defun foo (regex target-string &amp;key (start 0) (end (length target-string)))
    (let ((sum 0))
      (cl-ppcre:do-matches (s e regex target-string nil :start start :end end)
        (incf sum (- e s)))
      (format t "~,2F% of the string was inside of a match~%"
                <font color=orange>;; note: doesn't check for division by zero</font>
                (float (* 100 (/ sum (- end start)))))))

FOO

* (foo "a" "abcabcabc")
33.33% of the string was inside of a match
NIL
* (foo "aa|b" "aacabcbbc")
55.56% of the string was inside of a match
NIL
</pre></blockquote>




<p><br>[Macro]
<br><a class=none name="do-matches-as-strings"><b>do-matches-as-strings</b> <i>(match-var regex target-string <tt>&amp;optional</tt> result-form <tt>&amp;key</tt> start end sharedp) declaration* statement*</i> =&gt; <i>result*</i></a>

<blockquote><br>
Like <a href="#do-matches"><code>DO-MATCHES</code></a> but binds
<code><i>match-var</i></code> to the substring of
<code><i>target-string</i></code> corresponding to each match in turn. If <code><i>sharedp</i></code> is true, the substrings may share structure with
<code><i>target-string</i></code>.
<p>
Example:
<pre>
* (defun crossfoot (target-string &amp;key (start 0) (end (length target-string)))
    (let ((sum 0))
      (cl-ppcre:do-matches-as-strings (m :digit-class
                                         target-string nil
                                         :start start :end end)
        (incf sum (parse-integer m)))
      (if (< sum 10)
        sum
        (crossfoot (format nil "~A" sum)))))

CROSSFOOT

* (crossfoot "bar")
0

* (crossfoot "a3x")
3

* (crossfoot "12345")
6
</pre>

Of course, in real life you would do this with <a href="#do-matches"><code>DO-MATCHES</code></a> and use the <code><i>start</i></code> and <code><i>end</i></code> keyword parameters of <a href="http://www.lispworks.com/reference/HyperSpec/Body/f_parse_.htm"><code>PARSE-INTEGER</code></a>.</blockquote>

<p><br>[Macro]
<br><a class=none name="do-register-groups"><b>do-register-groups</b> <i>var-list (regex target-string <tt>&amp;optional</tt> result-form <tt>&amp;key</tt> start end sharedp) declaration* statement*</i> =&gt; <i>result*</i></a>

<blockquote><br>
Iterates over <code><i>target-string</i></code> and tries to match <code><i>regex</i></code> as often as
possible evaluating <code><i>statement*</i></code> with the variables in <code><i>var-list</i></code> bound to the
corresponding register groups for each match in turn, i.e. each
variable is either bound to a string or to <code>NIL</code>. You can use the same shortcuts and abbreviations as in <a href="#register-groups-bind"><code>REGISTER-GROUPS-BIND</code></a>. The number of
variables in <code><i>var-list</i></code> must not be greater than the number of register
groups. For each element of
<code><i>var-list</i></code> which is <code>NIL</code> there's no binding to the corresponding register
group. After the last match, returns <code><i>result-form</i></code> if provided or <code>NIL</code>
otherwise. An implicit block named <code>NIL</code> surrounds <code>DO-REGISTER-GROUPS</code>;
<code>RETURN</code> may be used to terminate the loop immediately. If <code><i>regex</i></code> matches
an empty string the scan is continued one position behind this
match. If <code><i>sharedp</i></code> is true, the substrings may share structure with
<code><i>target-string</i></code>.
<p>Example:
<pre>
* (do-register-groups (first second third fourth)
      (&quot;((a)|(b)|(c))&quot; &quot;abababc&quot; nil :start 2 :sharedp t)
    (print (list first second third fourth)))
(&quot;a&quot; &quot;a&quot; NIL NIL) 
(&quot;b&quot; NIL &quot;b&quot; NIL) 
(&quot;a&quot; &quot;a&quot; NIL NIL) 
(&quot;b&quot; NIL &quot;b&quot; NIL) 
(&quot;c&quot; NIL NIL &quot;c&quot;)
NIL

* (let (result)
    (do-register-groups ((#'parse-integer n) (#'intern sign) whitespace)
        (&quot;(\\d+)|(\\+|-|\\*|/)|(\\s+)&quot; &quot;12*15 - 42/3&quot;)
      (unless whitespace
        (push (or n sign) result)))
    (nreverse result))
(12 * 15 - 42 / 3)
</pre>
</blockquote>


<p><br>[Function]
<br><a class=none name="all-matches"><b>all-matches</b> <i>regex target-string <tt>&amp;key</tt> start end</i> =&gt; <i>list</i></a>

<blockquote><br>
Returns a list containing the start and end positions of all matches
of <code><i>regex</i></code> against
<code><i>target-string</i></code>, i.e. if there are <code>N</code>
matches the list contains <code>(* 2 N)</code> elements. If
<code><i>regex</i></code> matches an empty string the scan is
continued one position behind this match.
<p>
Examples:
<pre>
* (cl-ppcre:all-matches "a" "foo bar baz")
(5 6 9 10)

* (cl-ppcre:all-matches "\\w*" "foo bar baz")
(0 3 3 3 4 7 7 7 8 11 11 11)
</pre></blockquote>




<p><br>[Function]
<br><a class=none name="all-matches-as-strings"><b>all-matches-as-strings</b> <i>regex target-string <tt>&amp;key</tt> start end sharedp</i> =&gt; <i>list</i></a>

<blockquote><br>
Like <a href="#all-matches"><code>ALL-MATCHES</code></a> but
returns a list of substrings instead. If <code><i>sharedp</i></code> is true, the substrings may share structure with
<code><i>target-string</i></code>.
<p>
Examples:
<pre>
* (cl-ppcre:all-matches-as-strings "a" "foo bar baz")
("a" "a")

* (cl-ppcre:all-matches-as-strings "\\w*" "foo bar baz")
("foo" "" "bar" "" "baz" "")
</pre></blockquote>






<p><br>[Function]
<br><a class=none name="split"><b>split</b> <i>regex target-string <tt>&amp;key</tt> start end limit with-registers-p omit-unmatched-p sharedp</i> =&gt; <i>list</i></a>

<blockquote><br>
Matches <code><i>regex</i></code> against
<code><i>target-string</i></code> as often as possible and returns a
list of the substrings between the matches. If
<code><i>with-registers-p</i></code> is true, substrings corresponding
to matched registers are inserted into the list as well.  If
<code><i>omit-unmatched-p</i></code> is true, unmatched registers will
simply be left out, otherwise they will show up as
<code>NIL</code>. <code><i>limit</i></code> limits the number of
elements returned - registers aren't counted. If
<code><i>limit</i></code> is <code>NIL</code> (or 0 which is
equivalent), trailing empty strings are removed from the result list.
If <code><i>regex</i></code> matches an empty string the scan is
continued one position behind this match. If <code><i>sharedp</i></code> is true, the substrings may share structure with
<code><i>target-string</i></code>.
<p>
Beginning with CL-PPCRE&nbsp;0.2.0, this function also tries hard to be
Perl-compatible - thus the somewhat peculiar behaviour. But note that
it hasn't been as extensively tested as <a
href="#scan"><code>SCAN</code></a>.
<p>
Examples:
<pre>
* (cl-ppcre:split "\\s+" "foo   bar baz
frob")
("foo" "bar" "baz" "frob")

* (cl-ppcre:split "\\s*" "foo bar   baz")
("f" "o" "o" "b" "a" "r" "b" "a" "z")

* (cl-ppcre:split "(\\s+)" "foo bar   baz")
("foo" "bar" "baz")

* (cl-ppcre:split "(\\s+)" "foo bar   baz" :with-registers-p t)
("foo" " " "bar" "   " "baz")

* (cl-ppcre:split "(\\s)(\\s*)" "foo bar   baz" :with-registers-p t)
("foo" " " "" "bar" " " "  " "baz")

* (cl-ppcre:split "(,)|(;)" "foo,bar;baz" :with-registers-p t)
("foo" "," NIL "bar" NIL ";" "baz")

* (cl-ppcre:split "(,)|(;)" "foo,bar;baz" :with-registers-p t :omit-unmatched-p t)
("foo" "," "bar" ";" "baz")

* (cl-ppcre:split ":" "a:b:c:d:e:f:g::")
("a" "b" "c" "d" "e" "f" "g")

* (cl-ppcre:split ":" "a:b:c:d:e:f:g::" :limit 1)
("a:b:c:d:e:f:g::")

* (cl-ppcre:split ":" "a:b:c:d:e:f:g::" :limit 2)
("a" "b:c:d:e:f:g::")

* (cl-ppcre:split ":" "a:b:c:d:e:f:g::" :limit 3)
("a" "b" "c:d:e:f:g::")

* (cl-ppcre:split ":" "a:b:c:d:e:f:g::" :limit 1000)
("a" "b" "c" "d" "e" "f" "g" "" "")
</pre></blockquote>





<p><br>[Function]
<br><a class=none name="regex-replace"><b>regex-replace</b> <i>regex target-string replacement <tt>&amp;key</tt> start end preserve-case simple-calls</i> =&gt; <i>list</i></a>

<blockquote><br> Try to match <code><i>target-string</i></code>
between <code><i>start</i></code> and <code><i>end</i></code> against
<code><i>regex</i></code> and replace the first match with
<code><i>replacement</i></code>.
<p>
<code><i>replacement</i></code> can be a string which may contain the
special substrings <code>&quot;\&amp;&quot;</code> for the whole
match, <code>&quot;\`&quot;</code> for the part of
<code><i>target-string</i></code> before the match,
<code>&quot;\'&quot;</code> for the part of
<code><i>target-string</i></code> after the match,
<code>&quot;\N&quot;</code> or <code>&quot;\{N}&quot;</code> for the
<code>N</code>th register where <code>N</code> is a positive integer.
<p>
<code><i>replacement</i></code> can also be a <a
href="http://www.lispworks.com/reference/HyperSpec/Body/26_glo_f.htm#function_designator">function
designator</a> in which case the match will be replaced with the
result of calling the function designated by
<code><i>replacement</i></code> with the arguments
<code><i>target-string</i></code>, <code><i>start</i></code>,
<code><i>end</i></code>, <code><i>match-start</i></code>,
<code><i>match-end</i></code>, <code><i>reg-starts</i></code>, and
<code><i>reg-ends</i></code>. (<code><i>reg-starts</i></code> and
<code><i>reg-ends</i></code> are arrays holding the start and end
positions of matched registers (or <code>NIL</code>) - the meaning of
the other arguments should be obvious.)
<p>
If <code><i>simple-calls</i></code> is true, a function designated by
<code><i>replacement</i></code> will instead be called with the
arguments <code><i>match</i></code>, <code><i>register-1</i></code>,
..., <code><i>register-n</i></code> where <code><i>match</i></code> is
the whole match as a string and <code><i>register-1</i></code> to
<code><i>register-n</i></code> are the matched registers, also as
strings (or <code>NIL</code>). Note that these strings share structure with
<code><i>target-string</i></code> so you must not modify them.
<p>
Finally, <code><i>replacement</i></code> can be a list where each
element is a string (which will be inserted verbatim), one of the
symbols <code>:match</code>, <code>:before-match</code>, or
<code>:after-match</code> (corresponding to
<code>&quot;\&amp;&quot;</code>, <code>&quot;\`&quot;</code>, and
<code>&quot;\'&quot;</code> above), an integer <code>N</code>
(representing register <code>(1+&nbsp;N)</code>), or a function
designator.
<p>
If <code><i>preserve-case</i></code> is true (default is
<code>NIL</code>), the replacement will try to preserve the case (all
upper case, all lower case, or capitalized) of the match. The result
will always be a <a
href="http://www.lispworks.com/reference/HyperSpec/Body/26_glo_f.htm#fresh">fresh</a>
string, even if <code><i>regex</i></code> doesn't match.
<p>
Examples:

<pre>
* (cl-ppcre:regex-replace "fo+" "foo bar" "frob")
"frob bar"

* (cl-ppcre:regex-replace "fo+" "FOO bar" "frob")
"FOO bar"

* (cl-ppcre:regex-replace "(?i)fo+" "FOO bar" "frob")
"frob bar"

* (cl-ppcre:regex-replace "(?i)fo+" "FOO bar" "frob" :preserve-case t)
"FROB bar"

* (cl-ppcre:regex-replace "(?i)fo+" "Foo bar" "frob" :preserve-case t)
"Frob bar"

* (cl-ppcre:regex-replace "bar" "foo bar baz" "[frob (was '\\&' between '\\`' and '\\'')]")
"foo [frob (was 'bar' between 'foo ' and ' baz')] baz"

* (cl-ppcre:regex-replace "bar" "foo bar baz"
                          '("[frob (was '" :match "' between '" :before-match "' and '" :after-match "')]"))
"foo [frob (was 'bar' between 'foo ' and ' baz')] baz"
</pre></blockquote>


<p><br>[Function]
<br><a class=none name="regex-replace-all"><b>regex-replace-all</b> <i>regex target-string replacement <tt>&amp;key</tt> start end preserve-case simple-calls</i> =&gt; <i>list</i></a>

<blockquote><br>
Like <a href="#regex-replace"><code>REGEX-REPLACE</code></a> but replaces all matches.
<p>
Examples:

<pre>
* (cl-ppcre:regex-replace-all "(?i)fo+" "foo Fooo FOOOO bar" "frob" :preserve-case t)
"frob Frob FROB bar"

* (cl-ppcre:regex-replace-all "(?i)f(o+)" "foo Fooo FOOOO bar" "fr\\1b" :preserve-case t)
"froob Frooob FROOOOB bar"

* (let ((qp-regex (cl-ppcre:create-scanner "[\\x80-\\xff]")))
    (defun encode-quoted-printable (string)
      "Convert 8-bit string to quoted-printable representation."
      <font color=orange>;; won't work for Corman Lisp because non-ASCII characters aren't 8-bit there</font>
      (flet ((convert (target-string start end match-start match-end reg-starts reg-ends)
             (declare (ignore start end match-end reg-starts reg-ends))
             (format nil "=~2,'0x" (char-code (char target-string match-start)))))
        (cl-ppcre:regex-replace-all qp-regex string #'convert))))
Converted ENCODE-QUOTED-PRINTABLE.
ENCODE-QUOTED-PRINTABLE

* (encode-quoted-printable "F&ecirc;te S&oslash;rensen na&iuml;ve H&uuml;hner Stra&szlig;e")
"F=EAte S=F8rensen na=EFve H=FChner Stra=DFe"

* (let ((url-regex (cl-ppcre:create-scanner "[^a-zA-Z0-9_\\-.]")))
    (defun url-encode (string)
      "URL-encode a string."
      <font color=orange>;; won't work for Corman Lisp because non-ASCII characters aren't 8-bit there</font>
      (flet ((convert (target-string start end match-start match-end reg-starts reg-ends)
             (declare (ignore start end match-end reg-starts reg-ends))
             (format nil "%~2,'0x" (char-code (char target-string match-start)))))
        (cl-ppcre:regex-replace-all url-regex string #'convert))))
Converted URL-ENCODE.
URL-ENCODE

* (url-encode "F&ecirc;te S&oslash;rensen na&iuml;ve H&uuml;hner Stra&szlig;e")
"F%EAte%20S%F8rensen%20na%EFve%20H%FChner%20Stra%DFe"

* (defun how-many (target-string start end match-start match-end reg-starts reg-ends)
    (declare (ignore start end match-start match-end))
    (format nil "~A" (- (svref reg-ends 0)
                        (svref reg-starts 0))))
HOW-MANY

* (cl-ppcre:regex-replace-all "{(.+?)}"
                              "foo{...}bar{.....}{..}baz{....}frob"
                              (list "[" 'how-many " dots]"))
"foo[3 dots]bar[5 dots][2 dots]baz[4 dots]frob"

* (let ((qp-regex (cl-ppcre:create-scanner "[\\x80-\\xff]")))
    (defun encode-quoted-printable (string)
      "Convert 8-bit string to quoted-printable representation.
Version using SIMPLE-CALLS keyword argument."
      <font color=orange>;; ;; won't work for Corman Lisp because non-ASCII characters aren't 8-bit there</font>
      (flet ((convert (match)
               (format nil "=~2,'0x" (char-code (char match 0)))))
        (cl-ppcre:regex-replace-all qp-regex string #'convert
                                    :simple-calls t))))

Converted ENCODE-QUOTED-PRINTABLE.
ENCODE-QUOTED-PRINTABLE

* (encode-quoted-printable "F&ecirc;te S&oslash;rensen na&iuml;ve H&uuml;hner Stra&szlig;e")
"F=EAte S=F8rensen na=EFve H=FChner Stra=DFe"

* (defun how-many (match first-register)
    (declare (ignore match))
    (format nil "~A" (length first-register)))
HOW-MANY

* (cl-ppcre:regex-replace-all "{(.+?)}"
                              "foo{...}bar{.....}{..}baz{....}frob"
                              (list "[" 'how-many " dots]")
                              :simple-calls t)

"foo[3 dots]bar[5 dots][2 dots]baz[4 dots]frob"
</pre></blockquote>

<p><br>[Function]
<br><a class=none name="regex-apropos"><b>regex-apropos</b> <i>regex <tt>&amp;optional</tt> packages <tt>&amp;key</tt> case-insensitive</i> =&gt; <i>list</i></a>

<blockquote><br>
Like <a
href="http://www.lispworks.com/reference/HyperSpec/Body/f_apropo.htm"><code>APROPOS</code></a>
but searches for interned symbols which match the regular expression
<code><i>regex</i></code>. The output is implementation-dependent. If
<code><i>case-insensitive</i></code> is true (which is the default)
and <code><i>regex</i></code> isn't already a scanner, a
case-insensitive scanner is used.
<p>
Here are examples for CMUCL:

<pre>
* *package*
#&lt;The COMMON-LISP-USER package, 16/21 internal, 0/9 external&gt;

* (defun foo (n &amp;optional (k 0)) (+ 3 n k))
FOO

* (defparameter foo "bar")
FOO

* (defparameter |foobar| 42)
|foobar|

* (defparameter fooboo 43)
FOOBOO

* (defclass frobar () ())
#&lt;STANDARD-CLASS FROBAR {4874E625}&gt;

* (cl-ppcre:regex-apropos "foo(?:bar)?")
FOO [variable] value: "bar"
    [compiled function] (N &amp;OPTIONAL (K 0))
FOOBOO [variable] value: 43
|foobar| [variable] value: 42

* (cl-ppcre:regex-apropos "(?:foo|fro)bar")
PCL::|COMMON-LISP-USER::FROBAR class predicate| [compiled closure]
FROBAR [class] #&lt;STANDARD-CLASS FROBAR {4874E625}&gt;
|foobar| [variable] value: 42

* (cl-ppcre:regex-apropos "(?:foo|fro)bar" 'cl-user)
FROBAR [class] #&lt;STANDARD-CLASS FROBAR {4874E625}&gt;
|foobar| [variable] value: 42

* (cl-ppcre:regex-apropos "(?:foo|fro)bar" '(pcl ext))
PCL::|COMMON-LISP-USER::FROBAR class predicate| [compiled closure]

* (cl-ppcre:regex-apropos "foo")
FOO [variable] value: "bar"
    [compiled function] (N &amp;OPTIONAL (K 0))
FOOBOO [variable] value: 43
|foobar| [variable] value: 42

* (cl-ppcre:regex-apropos "foo" nil :case-insensitive nil)
|foobar| [variable] value: 42
</pre></blockquote>




<p><br>[Function]
<br><a class=none name="regex-apropos-list"><b>regex-apropos-list</b> <i>regex <tt>&amp;optional</tt> packages <tt>&amp;key</tt> upcase</i> =&gt; <i>list</i></a>

<blockquote><br>
Like <a
href="http://www.lispworks.com/reference/HyperSpec/Body/f_apropo.htm"><code>APROPOS-LIST</code></a>
but searches for interned symbols which match the regular expression
<code><i>regex</i></code>. If <code><i>case-insensitive</i></code> is
true (which is the default) and <code><i>regex</i></code> isn't
already a scanner, a case-insensitive scanner is used.
<p>
Example (continued from above):

<pre>
* (cl-ppcre:regex-apropos-list &quot;foo(?:bar)?&quot;)
(|foobar| FOOBOO FOO)
</pre></blockquote>

<p><br>[Special variable]
<br><a class=none name="regex-char-code-limit"><b>*regex-char-code-limit*</b></a>

<blockquote><br>This variable controls whether scanners take into
account all characters of your CL implementation or only those the <a
href="http://www.lispworks.com/reference/HyperSpec/Body/f_char_c.htm#char-code"><code>CHAR-CODE</code></a>
of which is not larger than its value. It is only relevant if the
regular expression contains certain character classes. The default is
<a
href="http://www.lispworks.com/reference/HyperSpec/Body/v_char_c.htm"><code>CHAR-CODE-LIMIT</code></a>,
and you might see significant speed and space improvements during
scanner <em>creation</em> if, say, your target strings only contain <a
href="http://wwwwbs.cs.tu-berlin.de/user/czyborra/charsets/">ISO-8859-1</a>
characters and you're using an implementation like AllegroCL,
LispWorks, or CLISP where <code>CHAR-CODE-LIMIT</code> has a value
much higher than 255. The <a href="#test">test suite</a> will
automatically set <code>*REGEX-CHAR-CODE-LIMIT*</code> to 255 while
you're running the default test.
<p>
Here's an example with LispWorks:

<pre>
CL-USER 23 > (time (cl-ppcre:create-scanner "[3\\D]"))
Timing the evaluation of (CL-PPCRE:CREATE-SCANNER "[3\\D]")

user time    =      0.443
system time  =      0.001
Elapsed time =   0:00:01
Allocation   = 546600 bytes standard / 2162611 bytes fixlen
0 Page faults
#&lt;closure 20654AF2&gt;

CL-USER 24 > (time (let ((cl-ppcre:*regex-char-code-limit* 255)) (cl-ppcre:create-scanner "[3\\D]")))
Timing the evaluation of (LET ((CL-PPCRE:*REGEX-CHAR-CODE-LIMIT* 255)) (CL-PPCRE:CREATE-SCANNER "[3\\D]"))

user time    =      0.000
system time  =      0.000
Elapsed time =   0:00:00
Allocation   = 3336 bytes standard / 8338 bytes fixlen
0 Page faults
#&lt;closure 206569DA&gt;
</pre>
<p>
Note: Due to the nature of <code>LOAD-TIME-VALUE</code> and the <a
href="#compiler-macro">compiler macro for <code>SCAN</code></a> some
scanners might be created in a <a
href="http://www.lispworks.com/reference/HyperSpec/Body/26_glo_n.htm#null_lexical_environment">null
lexical environment</a> at load time or at compile time so be careful
to which value <code>*REGEX-CHAR-CODE-LIMIT*</code> is bound at that
time. The default value should always yield correct results unless you
play dirty tricks with implementation-dependent behaviour, though.</blockquote>

<p><br>[Special variable]
<br><a class=none name="use-bmh-matchers"><b>*use-bmh-matchers*</b></a>

<blockquote><br>Usually, the scanners created by <a
href="#create-scanner"><code>CREATE-SCANNER</code></a> (or
implicitely by other functions and macros) will use fast <a
href="http://www-igm.univ-mlv.fr/~lecroq/string/node18.html">Boyer-Moore-Horspool
matchers</a> to check for constant strings at the start or end of the
regular expression. If <code>*USE-BMH-MATCHERS*</code> is
<code>NIL</code> (the default is <code>T</code>), the standard
function <a
href="http://www.lispworks.com/reference/HyperSpec/Body/f_search.htm"><code>SEARCH</code></a>
will be used instead. This will usually be a bit slower but can save
lots of space if you're storing many scanners. The <a
href="#test">test suite</a> will automatically set
<code>*USE-BMH-MATCHERS*</code> to <code>NIL</code> while you're running
the default test.
<p>
Note: Due to the nature of <code>LOAD-TIME-VALUE</code> and the <a
href="#compiler-macro">compiler macro for <code>SCAN</code></a> some
scanners might be created in a <a
href="http://www.lispworks.com/reference/HyperSpec/Body/26_glo_n.htm#null_lexical_environment">null
lexical environment</a> at load time or at compile time so be careful
to which value <code>*USE-BMH-MATCHERS*</code> is bound at that
time.</blockquote>

<p><br>[Special variable]
<br><a class=none name="*allow-quoting*"><b>*allow-quoting*</b></a>

<blockquote><br>
If this value is <em>true</em> (the default is <code>NIL</code>)
CL-PPCRE will support <code>\Q</code> and <code>\E</code> in regex
strings to quote (disable) metacharacters. Note that this entails a
slight performance penalty when creating scanners because (a copy of) the regex
string is modified (probably more than once) before it
is fed to the parser. Also, the parser's <a
href="#ppcre-syntax-error">syntax error messages</a> will complain
about the converted string and not about the original regex string.

<pre>
* (cl-ppcre:scan &quot;^a+$&quot; &quot;a+&quot;)
NIL

* (let ((cl-ppcre:*allow-quoting* t))
    (cl-ppcre:scan &quot;^\\Qa+\\E$&quot; &quot;a+&quot;))
0
2
#()
#()

* (let ((cl-ppcre:*allow-quoting* t))
    (cl-ppcre:scan &quot;\\Qa()\\E(?#comment\\Q)a**b&quot; &quot;()ab&quot;))

Quantifier '*' not allowed at position 19 in string &quot;a\\(\\)(?#commentQ)a**b&quot;
</pre>

Note how in the last example the regex string in the error message is
different from the first argument to the <code>SCAN</code>
function. Also note that the second example might be easier to
understand (and Lisp-ier) if you write it like this:

<pre>
* (cl-ppcre:scan '(:sequence :start-anchor
                             &quot;a+&quot; <font color=orange>;; no quoting necessary</font>
                             :end-anchor)
                 &quot;a+&quot;)
0
2
#()
#()
</pre>

Make sure you also read <a href="#quote">the relevant section</a> in &quot;<a href="#bugs">Bugs and problems</a>.&quot;

</blockquote>

<p><br>[Function]
<br><a class=none name="quote-meta-chars"><b>quote-meta-chars</b> <i>string</i> =&gt; <i>string'</i></a>

<blockquote><br>
This is a simple utility function used when <a
href="#*allow-quoting*"><code>*ALLOW-QUOTING*</code></a> is
<em>true</em>. It returns a string <code>STRING'</code> where all
non-word characters (everything except ASCII characters, digits and
underline) of <code>STRING</code> are quoted by prepending a
backslash similar to Perl's <code>quotemeta</code> function. It always returns a <a
href="http://www.lispworks.com/reference/HyperSpec/Body/26_glo_f.htm#fresh">fresh</a>
string.
<pre>
* (cl-ppcre:quote-meta-chars &quot;[a-z]*&quot;)
&quot;\\[a\\-z\\]\\*&quot;
</pre></blockquote>

<p><br>[Condition type]
<br><a class=none name="ppcre-error"><b>ppcre-error</b></a>

<blockquote><br>
Every error signaled by CL-PPCRE is of type
<code>PPCRE-ERROR</code>. This is a direct subtype of <a
href="http://www.lispworks.com/reference/HyperSpec/Body/e_smp_er.htm"><code>SIMPLE-ERROR</code></a>
without any additional slots or options.
</blockquote>

<p><br>[Condition type]
<br><a class=none name="ppcre-invocation-error"><b>ppcre-invocation-error</b></a>

<blockquote><br>
Errors of type <code>PPCRE-INVOCATION-ERROR</code>
are signaled if one of the exported functions of CL-PPCRE is called with wrong or
inconsistent arguments. This is a direct subtype of <a
href="#ppcre-error"><code>PPCRE-ERROR</code></a> without any
additional slots or options.
</blockquote>

<p><br>[Condition type]
<br><a class=none name="ppcre-syntax-error"><b>ppcre-syntax-error</b></a>

<blockquote><br>
An error of type <code>PPCRE-SYNTAX-ERROR</code> is signaled if
CL-PPCRE's parser encounters an error when trying to parse a regex
string or to convert a parse tree into its internal representation.
This is a direct subtype of <a
href="#ppcre-error"><code>PPCRE-ERROR</code></a> with two additional
slots. These denote the regex string which HTML-PPCRE was parsing and
the position within the string where the error occured.  If the error
happens while CL-PPCRE is converting a parse tree both of these slots
contain <code>NIL</code>.  (See the next two entries on how to access
these slots.)
<p>
As many syntax errors can't be detected before the parser is at the
end of the stream, the row and column usually denote the last position
where the parser was happy and not the position where it gave up.

<pre>
* (handler-case
    (cl-ppcre:scan &quot;foo**x&quot; &quot;fooox&quot;)
    (cl-ppcre:ppcre-syntax-error (condition)
      (format t &quot;Houston, we've got a problem with the string ~S:~%~
                 Looks like something went wrong at position ~A.~%~
                 The last message we received was \&quot;~?\&quot;.&quot;
              (cl-ppcre:ppcre-syntax-error-string condition)
              (cl-ppcre:ppcre-syntax-error-pos condition)
              (simple-condition-format-control condition)
              (simple-condition-format-arguments condition))
      (values)))
Houston, we've got a problem with the string &quot;foo**x&quot;:
Looks like something went wrong at position 4.
The last message we received was &quot;Quantifier '*' not allowed&quot;.
</pre>
</blockquote>

<p><br>[Function]
<br><a class=none name="ppcre-syntax-error-string"><b>ppcre-syntax-error-string</b></a> <i>condition</i> =&gt; <i>string</i></a>

<blockquote><br>
If <code><i>condition</i></code> is a condition of type <a
href="#ppcre-syntax-error"><code>PPCRE-SYNTAX-ERROR</code></a> this
function will return the string the parser was parsing when the error was
encountered (or <code>NIL</code> if the error happened while trying to
convert a parse tree). This might be particularly useful when <a
href="#*allow-quoting*"><code>*ALLOW-QUOTING*</code></a> is
<em>true</em> because in this case the offending string might not be the one you gave to the <a
href="#create-scanner"><code>CREATE-SCANNER</code></a> function.
</blockquote>

<p><br>[Function]
<br><a class=none name="ppcre-syntax-error-pos"><b>ppcre-syntax-error-pos</b></a> <i>condition</i> =&gt; <i>number</i></a>

<blockquote><br>
If <code><i>condition</i></code> is a condition of type <a
href="#ppcre-syntax-error"><code>PPCRE-SYNTAX-ERROR</code></a> this
function will return the position within the string where the error
occured (or <code>NIL</code> if the error happened while trying to
convert a parse tree).
</blockquote>


<br>&nbsp;<br><h3><a name="filters" class=none>Filters</a></h3>

Because several users have asked for it, CL-PPCRE now offers
&quot;filters&quot; (see <a href="#filterdef">above</a> for syntax)
which are basically arbitrary, user-defined functions that can act as
regex building blocks. Filters can only be used within <a
href="#create-scanner2">parse trees</a>, not within Perl regex
strings.
<p>
Note that filters are currently considered an experimental feature and
their API might change in the future.
<p>
A filter is defined by its <em>filter function</em> which must be a
function of one argument. During the parsing process this function
might be called once or several times or it might not be called at
all. If it's called its argument is an integer <code><i>pos</i></code>
which is the current position within the target string. The filter can
either return <code>NIL</code> (which means that the subexpression
represented by this filter didn't match) or an integer not smaller
than <code><i>pos</i></code> for success. A zero-length assertion
should return <code><i>pos</i></code> itself while a filter which
wants to consume <code>N</code> characters should return
<code>(+&nbsp;POS&nbsp;N)</code>.
<p>
If you supply the optional value <code><i>length</i></code> and it is
not <code>NIL</code> then this is a promise to the regex engine that
your filter will <em>always</em> consume <em>exactly</em>
<code><i>length</i></code> characters. The regex engine might use this
information for optimization purposes but it is otherwise irrelevant
to the outcome of the matching process.
<p>
The filter function can access the following special variables from
its code body:
<ul>

<li><code>CL-PPCRE::*STRING*</code>: The target (a string) of the
current matching process.

<li><code>CL-PPCRE::*START-POS*</code> and
<code>CL-PPCRE::*END-POS*</code>: The start and end (integers) indices
of the current matching process. These correspond to the
<code>START</code> and <code>END</code> keyword parameters of <a
href="#scan"><code>SCAN</code></a>.

<li><code>CL-PPCRE::*REAL-START-POS*</code>: The initial starting
position. This is only relevant for repeated scans (as in <a
href="#do-scans"><code>DO-SCANS</code></a>) where
<code>CL-PPCRE::*START-POS*</code> will be moved forward while
<code>CL-PPCRE::*REAL-START-POS*</code> won't. For normal scans the
value of this variable is <code>NIL</code>.

<li><CODE>CL-PPCRE::*REG-STARTS*</CODE> and
<CODE>CL-PPCRE::*REG-ENDS*</CODE>: Two simple vectors which denote the
start and end indices of registers within the regular expression. The
first register is indexed by&nbsp;0. If a register hasn't matched yet
then its corresponding entry in <CODE>CL-PPCRE::*REG-STARTS*</CODE> is
<code>NIL</code>.

</ul>

These variables should be considered read-only. Do <em>not</em> change
these values unless you really know what you're doing!
<p>
Note that the names of the variables are not exported from the
<code>CL-PPCRE</code> package because there's currently no guarantee
that they will be available in future releases.
<p>
Here are some filter examples:
<pre>
* (defun my-info-filter (pos)
    &quot;Show some info about the matching process.&quot;
    (format t &quot;Called at position ~A~%&quot; pos)
    (loop with dim = (array-dimension cl-ppcre::*reg-starts* 0)
          for i below dim
          for reg-start = (aref cl-ppcre::*reg-starts* i)
          for reg-end = (aref cl-ppcre::*reg-ends* i)
          do (format t &quot;Register ~A is currently &quot; (1+ i))
          when reg-start
               (write-string cl-ppcre::*string* nil
            do (write-char #\')
               (write-string cl-ppcre::*string* nil
                     :start reg-start :end reg-end)
               (write-char #\')
          else
            do (write-string &quot;unbound&quot;)
          do (terpri))
    (terpri)
    pos)
MY-INFO-FILTER

* (scan '(:sequence
           (:register
             (:greedy-repetition 0 nil
                                 (:char-class (:range #\a #\z))))
           (:filter my-info-filter 0) &quot;X&quot;)
        &quot;bYcdeX&quot;)
Called at position 1
Register 1 is currently 'b'

Called at position 0
Register 1 is currently ''

Called at position 1
Register 1 is currently ''

Called at position 5
Register 1 is currently 'cde'

2
6
#(2)
#(5)

* (scan '(:sequence
           (:register
             (:greedy-repetition 0 nil
                                 (:char-class (:range #\a #\z))))
           (:filter my-info-filter 0) &quot;X&quot;)
        &quot;bYcdeZ&quot;)
NIL

* (defun my-weird-filter (pos)
    &quot;Only match at this point if either pos is odd and the character
  we're looking at is lowerrcase or if pos is even and the next two
  characters we're looking at are uppercase. Consume these characters if
  there's a match.&quot;
    (format t &quot;Trying at position ~A~%&quot; pos)
    (cond ((and (oddp pos)
                (&lt; pos cl-ppcre::*end-pos*)
                (lower-case-p (char cl-ppcre::*string* pos)))
           (1+ pos))
          ((and (evenp pos)
                (&lt; (1+ pos) cl-ppcre::*end-pos*)
                (upper-case-p (char cl-ppcre::*string* pos))
                (upper-case-p (char cl-ppcre::*string* (1+ pos))))
           (+ pos 2))
          (t nil)))
MY-WEIRD-FILTER

* (defparameter *weird-regex*
                `(:sequence &quot;+&quot; (:filter ,#'my-weird-filter) &quot;+&quot;))
*WEIRD-REGEX*

* (scan *weird-regex* &quot;+A++a+AA+&quot;)
Trying at position 1
Trying at position 3
Trying at position 4
Trying at position 6
5
9
#()
#()

* (fmakunbound 'my-weird-filter)
MY-WEIRD-FILTER

* (scan *weird-regex* &quot;+A++a+AA+&quot;)
Trying at position 1
Trying at position 3
Trying at position 4
Trying at position 6
5
9
#()
#()
</pre>

Note that in the second call to <code>SCAN</code> our filter wasn't
invoked at all - it was optimized away by the regex engine because it
knew that it couldn't match. Also note that <code>*WEIRD-REGEX*</code>
still worked after we removed the global function definition of
<code>MY-WEIRD-FILTER</code> because the regular expression had
captured the original definition.

<p>

For more ideas about what you can do with filters see <a
href="http://common-lisp.net/pipermail/cl-ppcre-devel/2004-October/000069.html">this
thread</a> on the <a href="#mail">mailing list</a>.

<br>&nbsp;<br><h3><a name="test" class=none>Testing CL-PPCRE</a></h3>

CL-PPCRE comes with a comprehensive test suite most of which is stolen
from the <a href="http://www.pcre.org/">PCRE</a> library. You can use
it like this:

<pre>
* (mk:compile-system &quot;cl-ppcre-test&quot;)
<font color=orange>; Loading #p&quot;/home/edi/cl-ppcre/cl-ppcre.system&quot;.
; Loading #p&quot;/home/edi/cl-ppcre/packages.x86f&quot;.
; Loading #p&quot;/home/edi/cl-ppcre/specials.x86f&quot;.
; Loading #p&quot;/home/edi/cl-ppcre/util.x86f&quot;.
; Loading #p&quot;/home/edi/cl-ppcre/errors.x86f&quot;.
; Loading #p&quot;/home/edi/cl-ppcre/lexer.x86f&quot;.
; Loading #p&quot;/home/edi/cl-ppcre/parser.x86f&quot;.
; Loading #p&quot;/home/edi/cl-ppcre/regex-class.x86f&quot;.
; Loading #p&quot;/home/edi/cl-ppcre/convert.x86f&quot;.
; Loading #p&quot;/home/edi/cl-ppcre/optimize.x86f&quot;.
; Loading #p&quot;/home/edi/cl-ppcre/closures.x86f&quot;.
; Loading #p&quot;/home/edi/cl-ppcre/repetition-closures.x86f&quot;.
; Loading #p&quot;/home/edi/cl-ppcre/scanner.x86f&quot;.
; Loading #p&quot;/home/edi/cl-ppcre/api.x86f&quot;.
; Loading #p&quot;/home/edi/cl-ppcre/ppcre-tests.x86f&quot;.</font>
NIL

* (cl-ppcre-test:test)

<font color=orange>;; ....
;; (a list of <a class=noborder href="#perl">incompatibilities with Perl</a>)</font color=orange>
</pre>

(If you're not using MK:DEFSYSTEM or asdf it suffices to build
CL-PPCRE and then compile and load the file
<code>ppcre-tests.lisp</code>.)
<p>
With LispWorks, SCL, and SBCL (starting from version&nbsp;0.8.4.8) you can also call
<code>CL-PPCRE-TEST:TEST</code> with a keyword argument argument
<code>THREADED</code> which - in addition to the usual tests - will
also check whether the scanners created by CL-PPCRE are thread-safe.
<p>
Note that the file <code>testdata</code> provided with CL-PPCRE
was created on a Linux system with Perl 5.8.0. You can (and you
<em>should</em> if you're on Mac OS or Windows) create your own
<code>testdata</code> with the Perl script
<code>perltest.pl</code>:

<pre>
edi@bird:~/cl-ppcre &gt; perl perltest.pl &lt; testinput &gt; testdata
</pre>

Of course you can also create your own tests - the format accepted by
<code>perltest.pl</code> should be rather clear from looking at the
file <code>testinput</code>. Note that the target strings are wrapped
in double quotes and then fed to Perl's <code>eval</code> so you can
use ugly Perl constructs like, say, <code>a@{['b' x 10]}c</code> which
will result in the target string
<code>&quot;abbbbbbbbbbc&quot;</code>.

<br>&nbsp;<br><h3><a name="perl" class=none>Compatibility with Perl</a></h3>

Depending on your Perl version you might encounter a couple of small
incompatibilities with Perl most of which aren't due to CL-PPCRE:

<h4><a name="empty" class=none>Empty strings instead of <code>undef</code> in <code>$1</code>, <code>$2</code>, etc.</a></h4>

(Cf. case #629 of <a href="#test"><code>testdata</code></a>.)
This is <a
href="http://groups.google.com/groups?threadm=87u1kw8hfr.fsf%40dyn164.dbdmedia.de">a
bug</a> in Perl 5.6.1 and earlier which has been fixed in 5.8.0.

<h4><a name="scope" class=none>Strange scoping of embedded modifiers</a></h4>

(Cf. case #430 of <a href="#test"><code>testdata</code></a>.)
This is <a
href="http://groups.google.com/groups?threadm=871y80dpqh.fsf%40bird.agharta.de">a
bug</a> in Perl 5.6.1 and earlier which has been fixed in 5.8.0.

<h4><a name="inconsistent" class=none>Inconsistent capturing of <code>$1</code>, <code>$2</code>, etc.</a></h4>

(Cf. case #662 of <a href="#test"><code>testdata</code></a>.)
This is <a
href="http://bugs6.perl.org/rt2/Ticket/Display.html?id=18708">a
bug</a> in Perl which hasn't been fixed yet.

<h4><a name="lookaround" class=none>Captured groups not available outside of look-aheads and look-behinds</a></h4>

(Cf. case #1439 of <a href="#test"><code>testdata</code></a>.)
Well, OK, this ain't a Perl bug. I just can't quite understand why
captured groups should only be seen within the scope of a look-ahead
or look-behind. For the moment, CL-PPCRE and Perl agree to
disagree... :)

<h4><a name="order" class=none>Alternations don't always work from left to right</a></h4>

(Cf. case #790 of <a href="#test"><code>testdata</code></a>.) I
also think this a Perl bug but I currently have lost the drive to
report it.

<h4><a name="mac" class=none><code>&quot;\r&quot;</code> doesn't work with MCL</a></h4>

(Cf. case #9 of <a href="#test"><code>testdata</code></a>.) For
some strange reason that I don't understand MCL translates
<code>#\Return</code> to <code>(CODE-CHAR 10)</code> while MacPerl
translates <code>&quot;\r&quot;</code> to <code>(CODE-CHAR
13)</code>. Hmmm...

<h4><a name="alpha" class=none>What about <code>&quot;\w&quot;</code>?</a></h4>

CL-PPCRE uses <a
href="http://www.lispworks.com/reference/HyperSpec/Body/f_alphan.htm"><code>ALPHANUMERICP</code></a>
to decide whether a character matches Perl's
<code>&quot;\w&quot;</code>, so depending on your CL implementation
you might encounter differences between Perl and CL-PPCRE when
matching non-ASCII characters.

<br>&nbsp;<br><h3><a name="performance" class=none>Performance</a></h3>

<h4><a name="bench" class=none>Benchmarking</a></h4>

The <a href="">CL-PPCRE test suite</a> can also be used for
benchmarking purposes: If you call <code>perltest.pl</code> with a
command line argument it will be interpreted as the minimum number of seconds
each test should run. Perl will time its tests accordingly and create
output which, when fed to <code>CL-PPCRE-TEST:TEST</code>, will result
in a benchmark. Here's an example:

<pre>
edi@bird:~/cl-ppcre > echo &quot;/((a{0,5}){0,5})*[c]/
aaaaaaaaaaaac

/((a{0,5})*)*[c]/
aaaaaaaaaaaac&quot; | perl perltest.pl .5 > timedata
1
2

edi@bird:~/cl-ppcre > cmucl -quiet
<font color=orange>; Loading #p&quot;/home/edi/.cmucl-init&quot;.</font>

* (mk:compile-system &quot;cl-ppcre-test&quot;)
<font color=orange>; Loading #p&quot;/home/edi/cl-ppcre/cl-ppcre.system&quot;.
; Loading #p&quot;/home/edi/cl-ppcre/packages.x86f&quot;.
; Loading #p&quot;/home/edi/cl-ppcre/specials.x86f&quot;.
; Loading #p&quot;/home/edi/cl-ppcre/util.x86f&quot;.
; Loading #p&quot;/home/edi/cl-ppcre/errors.x86f&quot;.
; Loading #p&quot;/home/edi/cl-ppcre/lexer.x86f&quot;.
; Loading #p&quot;/home/edi/cl-ppcre/parser.x86f&quot;.
; Loading #p&quot;/home/edi/cl-ppcre/regex-class.x86f&quot;.
; Loading #p&quot;/home/edi/cl-ppcre/convert.x86f&quot;.
; Loading #p&quot;/home/edi/cl-ppcre/optimize.x86f&quot;.
; Loading #p&quot;/home/edi/cl-ppcre/closures.x86f&quot;.
; Loading #p&quot;/home/edi/cl-ppcre/repetition-closures.x86f&quot;.
; Loading #p&quot;/home/edi/cl-ppcre/scanner.x86f&quot;.
; Loading #p&quot;/home/edi/cl-ppcre/api.x86f&quot;.
; Loading #p&quot;/home/edi/cl-ppcre/ppcre-tests.x86f&quot;.</font>
NIL

* (cl-ppcre-test:test :file-name &quot;/home/edi/cl-ppcre/timedata&quot;)
   1: 0.5559 (1000000 repetitions, Perl: 4.5330 seconds, CL-PPCRE: 2.5200 seconds)
   2: 0.4573 (1000000 repetitions, Perl: 4.5922 seconds, CL-PPCRE: 2.1000 seconds)
NIL
</pre>

We gave two test cases to <code>perltest.pl</code> and asked it to repeat those tests often enough so that it takes at least 0.5 seconds to run each of them. In both cases, CMUCL was about twice as fast as Perl.
<p>
Here are some more benchmarks (done with Perl 5.6.1 and CMUCL 18d+):
<p>

<table border=1>
<tr><td><b>Test case</b></td><td><b>Repetitions</b></td><td><b>Perl (sec)</b></td><td><b>CL-PPCRE (sec)</b></td><td><b>Ratio CL-PPCRE/Perl</b></td></tr>
<tr><td><code>"@{['x' x 100]}" =~ /(.)*/s</code></td><td align=right>100000</td><td align=right>0.1394</td><td align=right>0.0700</td><td align=right>0.5022</td></tr>
<tr><td><code>"@{['x' x 1000]}" =~ /(.)*/s</code></td><td align=right>100000</td><td align=right>0.1628</td><td align=right>0.0600</td><td align=right>0.3685</td></tr>
<tr><td><code>"@{['x' x 10000]}" =~ /(.)*/s</code></td><td align=right>100000</td><td align=right>0.5071</td><td align=right>0.0600</td><td align=right>0.1183</td></tr>
<tr><td><code>"@{['x' x 100000]}" =~ /(.)*/s</code></td><td align=right>10000</td><td align=right>0.3902</td><td align=right>0.0000</td><td align=right>0.0000</td></tr>
<tr><td><code>"@{['x' x 100]}" =~ /.*/</code></td><td align=right>100000</td><td align=right>0.1520</td><td align=right>0.0800</td><td align=right>0.5262</td></tr>
<tr><td><code>"@{['x' x 1000]}" =~ /.*/</code></td><td align=right>100000</td><td align=right>0.3786</td><td align=right>0.5400</td><td align=right>1.4263</td></tr>
<tr><td><code>"@{['x' x 10000]}" =~ /.*/</code></td><td align=right>10000</td><td align=right>0.2709</td><td align=right>0.5100</td><td align=right>1.8826</td></tr>
<tr><td><code>"@{['x' x 100000]}" =~ /.*/</code></td><td align=right>1000</td><td align=right>0.2734</td><td align=right>0.5100</td><td align=right>1.8656</td></tr>
<tr><td><code>"@{['x' x 100]}" =~ /.*/s</code></td><td align=right>100000</td><td align=right>0.1320</td><td align=right>0.0300</td><td align=right>0.2274</td></tr>
<tr><td><code>"@{['x' x 1000]}" =~ /.*/s</code></td><td align=right>100000</td><td align=right>0.1634</td><td align=right>0.0300</td><td align=right>0.1836</td></tr>
<tr><td><code>"@{['x' x 10000]}" =~ /.*/s</code></td><td align=right>100000</td><td align=right>0.5304</td><td align=right>0.0300</td><td align=right>0.0566</td></tr>
<tr><td><code>"@{['x' x 100000]}" =~ /.*/s</code></td><td align=right>10000</td><td align=right>0.3966</td><td align=right>0.0000</td><td align=right>0.0000</td></tr>
<tr><td><code>"@{['x' x 100]}" =~ /x*/</code></td><td align=right>100000</td><td align=right>0.1507</td><td align=right>0.0900</td><td align=right>0.5970</td></tr>
<tr><td><code>"@{['x' x 1000]}" =~ /x*/</code></td><td align=right>100000</td><td align=right>0.3782</td><td align=right>0.6300</td><td align=right>1.6658</td></tr>
<tr><td><code>"@{['x' x 10000]}" =~ /x*/</code></td><td align=right>10000</td><td align=right>0.2730</td><td align=right>0.6000</td><td align=right>2.1981</td></tr>
<tr><td><code>"@{['x' x 100000]}" =~ /x*/</code></td><td align=right>1000</td><td align=right>0.2708</td><td align=right>0.5900</td><td align=right>2.1790</td></tr>
<tr><td><code>"@{['x' x 100]}" =~ /[xy]*/</code></td><td align=right>100000</td><td align=right>0.2637</td><td align=right>0.1500</td><td align=right>0.5688</td></tr>
<tr><td><code>"@{['x' x 1000]}" =~ /[xy]*/</code></td><td align=right>10000</td><td align=right>0.1449</td><td align=right>0.1200</td><td align=right>0.8282</td></tr>
<tr><td><code>"@{['x' x 10000]}" =~ /[xy]*/</code></td><td align=right>1000</td><td align=right>0.1344</td><td align=right>0.1100</td><td align=right>0.8185</td></tr>
<tr><td><code>"@{['x' x 100000]}" =~ /[xy]*/</code></td><td align=right>100</td><td align=right>0.1355</td><td align=right>0.1200</td><td align=right>0.8857</td></tr>
<tr><td><code>"@{['x' x 100]}" =~ /(.)*/</code></td><td align=right>100000</td><td align=right>0.1523</td><td align=right>0.1100</td><td align=right>0.7220</td></tr>
<tr><td><code>"@{['x' x 1000]}" =~ /(.)*/</code></td><td align=right>100000</td><td align=right>0.3735</td><td align=right>0.5700</td><td align=right>1.5262</td></tr>
<tr><td><code>"@{['x' x 10000]}" =~ /(.)*/</code></td><td align=right>10000</td><td align=right>0.2735</td><td align=right>0.5100</td><td align=right>1.8647</td></tr>
<tr><td><code>"@{['x' x 100000]}" =~ /(.)*/</code></td><td align=right>1000</td><td align=right>0.2598</td><td align=right>0.5000</td><td align=right>1.9242</td></tr>
<tr><td><code>"@{['x' x 100]}" =~ /(x)*/</code></td><td align=right>100000</td><td align=right>0.1565</td><td align=right>0.1300</td><td align=right>0.8307</td></tr>
<tr><td><code>"@{['x' x 1000]}" =~ /(x)*/</code></td><td align=right>100000</td><td align=right>0.3783</td><td align=right>0.6600</td><td align=right>1.7446</td></tr>
<tr><td><code>"@{['x' x 10000]}" =~ /(x)*/</code></td><td align=right>10000</td><td align=right>0.2720</td><td align=right>0.6000</td><td align=right>2.2055</td></tr>
<tr><td><code>"@{['x' x 100000]}" =~ /(x)*/</code></td><td align=right>1000</td><td align=right>0.2725</td><td align=right>0.6000</td><td align=right>2.2020</td></tr>
<tr><td><code>"@{['x' x 100]}" =~ /(y|x)*/</code></td><td align=right>10000</td><td align=right>0.2411</td><td align=right>0.1000</td><td align=right>0.4147</td></tr>
<tr><td><code>"@{['x' x 1000]}" =~ /(y|x)*/</code></td><td align=right>1000</td><td align=right>0.2313</td><td align=right>0.0900</td><td align=right>0.3891</td></tr>
<tr><td><code>"@{['x' x 10000]}" =~ /(y|x)*/</code></td><td align=right>100</td><td align=right>0.2336</td><td align=right>0.0900</td><td align=right>0.3852</td></tr>
<tr><td><code>"@{['x' x 100000]}" =~ /(y|x)*/</code></td><td align=right>10</td><td align=right>0.4165</td><td align=right>0.0900</td><td align=right>0.2161</td></tr>
<tr><td><code>"@{['x' x 100]}" =~ /([xy])*/</code></td><td align=right>100000</td><td align=right>0.2678</td><td align=right>0.1800</td><td align=right>0.6721</td></tr>
<tr><td><code>"@{['x' x 1000]}" =~ /([xy])*/</code></td><td align=right>10000</td><td align=right>0.1459</td><td align=right>0.1200</td><td align=right>0.8227</td></tr>
<tr><td><code>"@{['x' x 10000]}" =~ /([xy])*/</code></td><td align=right>1000</td><td align=right>0.1372</td><td align=right>0.1100</td><td align=right>0.8017</td></tr>
<tr><td><code>"@{['x' x 100000]}" =~ /([xy])*/</code></td><td align=right>100</td><td align=right>0.1358</td><td align=right>0.1100</td><td align=right>0.8098</td></tr>
<tr><td><code>"@{['x' x 100]}" =~ /((x){2})*/</code></td><td align=right>10000</td><td align=right>0.1073</td><td align=right>0.0400</td><td align=right>0.3727</td></tr>
<tr><td><code>"@{['x' x 1000]}" =~ /((x){2})*/</code></td><td align=right>10000</td><td align=right>0.9146</td><td align=right>0.2400</td><td align=right>0.2624</td></tr>
<tr><td><code>"@{['x' x 10000]}" =~ /((x){2})*/</code></td><td align=right>1000</td><td align=right>0.9020</td><td align=right>0.2300</td><td align=right>0.2550</td></tr>
<tr><td><code>"@{['x' x 100000]}" =~ /((x){2})*/</code></td><td align=right>100</td><td align=right>0.8983</td><td align=right>0.2300</td><td align=right>0.2560</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..100)]}FOOBARBAZ" =~ /[a-z]*FOOBARBAZ/</code></td><td align=right>100000</td><td align=right>0.2829</td><td align=right>0.2300</td><td align=right>0.8129</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..1000)]}FOOBARBAZ" =~ /[a-z]*FOOBARBAZ/</code></td><td align=right>10000</td><td align=right>0.1859</td><td align=right>0.1700</td><td align=right>0.9143</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..10000)]}FOOBARBAZ" =~ /[a-z]*FOOBARBAZ/</code></td><td align=right>1000</td><td align=right>0.1420</td><td align=right>0.1700</td><td align=right>1.1968</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..100)]}NOPE" =~ /[a-z]*FOOBARBAZ/</code></td><td align=right>1000000</td><td align=right>0.9196</td><td align=right>0.4600</td><td align=right>0.5002</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..1000)]}NOPE" =~ /[a-z]*FOOBARBAZ/</code></td><td align=right>100000</td><td align=right>0.2166</td><td align=right>0.2500</td><td align=right>1.1542</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..10000)]}NOPE" =~ /[a-z]*FOOBARBAZ/</code></td><td align=right>10000</td><td align=right>0.1465</td><td align=right>0.2300</td><td align=right>1.5696</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..100)]}FOOBARBAZ" =~ /([a-z])*FOOBARBAZ/</code></td><td align=right>100000</td><td align=right>0.2917</td><td align=right>0.2600</td><td align=right>0.8915</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..1000)]}FOOBARBAZ" =~ /([a-z])*FOOBARBAZ/</code></td><td align=right>10000</td><td align=right>0.1811</td><td align=right>0.1800</td><td align=right>0.9942</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..10000)]}FOOBARBAZ" =~ /([a-z])*FOOBARBAZ/</code></td><td align=right>1000</td><td align=right>0.1424</td><td align=right>0.1600</td><td align=right>1.1233</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..100)]}NOPE" =~ /([a-z])*FOOBARBAZ/</code></td><td align=right>1000000</td><td align=right>0.9154</td><td align=right>0.7400</td><td align=right>0.8083</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..1000)]}NOPE" =~ /([a-z])*FOOBARBAZ/</code></td><td align=right>100000</td><td align=right>0.2170</td><td align=right>0.2800</td><td align=right>1.2901</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..10000)]}NOPE" =~ /([a-z])*FOOBARBAZ/</code></td><td align=right>10000</td><td align=right>0.1497</td><td align=right>0.2300</td><td align=right>1.5360</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..100)]}FOOBARBAZ" =~ /([a-z]|ab)*FOOBARBAZ/</code></td><td align=right>10000</td><td align=right>0.4359</td><td align=right>0.1500</td><td align=right>0.3441</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..1000)]}FOOBARBAZ" =~ /([a-z]|ab)*FOOBARBAZ/</code></td><td align=right>1000</td><td align=right>0.5456</td><td align=right>0.1500</td><td align=right>0.2749</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..10000)]}FOOBARBAZ" =~ /([a-z]|ab)*FOOBARBAZ/</code></td><td align=right>10</td><td align=right>0.2039</td><td align=right>0.0600</td><td align=right>0.2943</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..100)]}NOPE" =~ /([a-z]|ab)*FOOBARBAZ/</code></td><td align=right>1000000</td><td align=right>0.9311</td><td align=right>0.7400</td><td align=right>0.7947</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..1000)]}NOPE" =~ /([a-z]|ab)*FOOBARBAZ/</code></td><td align=right>100000</td><td align=right>0.2162</td><td align=right>0.2700</td><td align=right>1.2489</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..10000)]}NOPE" =~ /([a-z]|ab)*FOOBARBAZ/</code></td><td align=right>10000</td><td align=right>0.1488</td><td align=right>0.2300</td><td align=right>1.5455</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..100)]}NOPE" =~ /[a-z]*FOOBARBAZ/i</code></td><td align=right>1000</td><td align=right>0.1555</td><td align=right>0.0000</td><td align=right>0.0000</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..1000)]}NOPE" =~ /[a-z]*FOOBARBAZ/i</code></td><td align=right>10</td><td align=right>0.1441</td><td align=right>0.0000</td><td align=right>0.0000</td></tr>
<tr><td><code>"@{[join undef, map { chr(ord('a') + rand 26) } (1..10000)]}NOPE" =~ /[a-z]*FOOBARBAZ/i</code></td><td align=right>10</td><td align=right>13.7150</td><td align=right>0.0100</td><td align=right>0.0007</td></tr>

</table>

<p>
As you might have noticed, Perl shines if it can reduce significant
parts of the matching process to cases where it can advance through
the target string one character at a time. This leads to C code where
you can very efficiently test and increment a pointer into a string in
a tight loop and can hardly be beaten with CL. In almost all other
cases, the CMUCL/CL-PPCRE combination is usually faster than Perl -
sometimes a lot faster.
<p>
As most of the examples above were chosen to make Perl look good
here's <a href="benchmarks.2002-12-22.txt">another benchmark</a> - the
result of running <a href="#test"><code>perltest.pl</code></a> against the
full <a href="#test"><code>testdata</code></a> file with a time
limit of 0.1 seconds, CL-PPCRE&nbsp;0.1.2 on CMUCL&nbsp;18e-pre
vs. Perl&nbsp;5.6.1. CL-PPCRE is faster than Perl in 1511 of 1545
cases - in 1045 cases it's more than twice as fast.
<p>
Note that Perl as well as CL-PPCRE keep the rightmost matches in
registers - keep that in mind if you benchmark against other regex
implementations. Also note that <code>CL-PPCRE-TEST:TEST</code>
automatically skips test cases where Perl and CL-PPCRE don't agree.

<h4><a name="other" class=none>Other performance issues</a></h4>

While the scanners created by CL-PPCRE are pretty fast, the process
which creates scanners from Perl regex strings and parse trees isn't
that speedy and conses a lot. It is recommended that you store and
re-use scanners if possible. The <code>DO-</code>macros will do this
for you automatically.
<p>
However, beginning with version&nbsp;0.5.2, CL-PPCRE uses a <a
name="compiler-macro"
href="http://www.lispworks.com/reference/HyperSpec/Body/26_glo_c.htm#compiler_macro">compiler
macro</a> and <a
href="http://www.lispworks.com/reference/HyperSpec/Body/s_ld_tim.htm"><code>LOAD-TIME-VALUE</code></a>
to make sure that the scanner is only built once if the first argument
to <a href="#scan"><code>SCAN</code></a>, <a href="#scan-to-strings"><code>SCAN-TO-STRINGS</code></a>, <a href="#split"><code>SPLIT</code></a>, 
<a href="#regex-replace"><code>REGEX-REPLACE</code></a>, or <a href="#regex-replace-all"><code>REGEX-REPLACE-ALL</code></a> is a <a
href="http://www.lispworks.com/reference/HyperSpec/Body/26_glo_c.htm#constant_form">constant
form</a>. (But see the notes for <a
href="#regex-char-code-limit"><code>*REGEX-CHAR-CODE-LIMIT*</code></a> and
<a href="#use-bmh-matchers"><code>*USE-BMH-MATCHERS*</code></a>.)
<p>
Here's an example of its effect

<pre>
* (trace cl-ppcre::convert)
(CL-PPCRE::CONVERT)
* (defun foo (string) (cl-ppcre:scan "(?s).*" string))
FOO
* (time (foo "The quick brown fox"))
Compiling LAMBDA NIL: 
Compiling Top-Level Form: 

  0: (CL-PPCRE::CONVERT #&lt;lambda-list-unavailable&gt;)
  0: CL-PPCRE::CONVERT returned
       #&lt;CL-PPCRE::SEQ {48B033C5}&gt;
       0
       #&lt;CL-PPCRE::EVERYTHING {48B031D5}&gt;
Evaluation took:
  0.0 seconds of real time
  0.00293 seconds of user run time
  9.77e-4 seconds of system run time
  0 page faults and
  11,408 bytes consed.
0
19
#()
#()
* (time (foo "The quick brown fox"))
Compiling LAMBDA NIL: 
Compiling Top-Level Form: 

  0: (CL-PPCRE::CONVERT #&lt;lambda-list-unavailable&gt;)
  0: CL-PPCRE::CONVERT returned
       #&lt;CL-PPCRE::SEQ {48B14C4D}&gt;
       0
       #&lt;CL-PPCRE::EVERYTHING {48B14B65}&gt;
Evaluation took:
  0.0 seconds of real time
  0.00293 seconds of user run time
  0.0 seconds of system run time
  0 page faults and
  10,960 bytes consed.
0
19
#()
#()
* (compile 'foo)
  0: (CL-PPCRE::CONVERT #&lt;lambda-list-unavailable&gt;)
  0: CL-PPCRE::CONVERT returned
       #&lt;CL-PPCRE::SEQ {48B1FEC5}&gt;
       0
       #&lt;CL-PPCRE::EVERYTHING {48B1FDDD}&gt;
Compiling LAMBDA (STRING): 
Compiling Top-Level Form: 
FOO
NIL
NIL
* (time (foo "The quick brown fox"))
Compiling LAMBDA NIL: 
Compiling Top-Level Form: 

Evaluation took:
  0.0 seconds of real time
  0.0 seconds of user run time
  0.0 seconds of system run time
  0 page faults and
  0 bytes consed.
0
19
#()
#()
* (time (foo "The quick brown fox"))
Compiling LAMBDA NIL: 
Compiling Top-Level Form: 

Evaluation took:
  0.0 seconds of real time
  0.0 seconds of user run time
  0.0 seconds of system run time
  0 page faults and
  0 bytes consed.
0
19
#()
#()
* 
</pre>

<p>
Of course, the usual rules for creating efficient regular expressions
apply to CL-PPCRE as well although it can optimize a couple of cases
itself. The most important rule is probably that you shouldn't use
capturing groups if you don't need the captured information, i.e. use
<code>&quot;(?:a|b)*&quot;</code> instead of
<code>&quot;(a|b)*&quot;</code> if you don't need to refer to the
register. (In fact, in this particular case CL-PPCRE will be able to
optimize away the register group, but it won't if you replace
<code>&quot;a|b&quot;</code> with, say,
<code>&quot;a|bc&quot;</code>.)
<p>
Another point worth mentioning is that you definitely should use
single-line mode if you have long strings without
<code>#\Newline</code> (or where you don't care about the line breaks)
and plan to use regular expressions like
<code>&quot;.*&quot;</code>. See the <a href="#bench">benchmarks</a>
for comparisons between single-line mode and normal mode with such
target strings.
<p>
Another thing to consider is that, for performance reasons, CL-PPCRE
assumes that most of the target strings you're trying to match are <a
href="http://www.lispworks.com/reference/HyperSpec/Body/t_smp_st.htm">simple
strings</a> and coerces non-simple strings to simple strings before
scanning them. If you plan on working with non-simple strings mostly
you might consider modifying the CL-PPCRE source code. This is easy:
Change all occurences of <code>SCHAR</code> to <code>CHAR</code> and
redefine the macro in <code>util.lisp</code> where the coercion takes
place - that's all.

<br>&nbsp;<br><h3><a name="bugs" class=none>Bugs and problems</a></h3>

<h4><a name="stack" class=none>Stack overflow</a></h4>

CL-PPCRE can optimize away a lot of unnecessary backtracking but
sometimes this simply isn't possible. With complicated regular
expressions and long strings this might lead to stack overflows
depending on your machine and your CL implementation.
<p>
Here's one example with CLISP:

<pre>
[1]> (defun target (n) (concatenate 'string (make-string n :initial-element #\a) "b"))
TARGET

[2]> (cl-ppcre:scan "a*" (target 1000))
0 ;
1000 ;
#() ;
#()

[3]> (cl-ppcre:scan "(?:a|b)*" (target 1000))
0 ;
1001 ;
#() ;
#()

[4]> (cl-ppcre:scan "(a|b)*" (target 1000))
0 ;
1001 ;
#(1000) ;
#(1001)

[5]> (cl-ppcre:scan "(a|b)*" (target 10000))
0 ;
10001 ;
#(10000) ;
#(10001)

[6]> (cl-ppcre:scan "(a|b)*" (target 100000))
0 ;
100001 ;
#(100000) ;
#(100001)

[7]> (cl-ppcre:scan "(a|b)*" (target 1000000))
0 ;
1000001 ;
#(1000000) ;
#(1000001)

<font color=orange>;; No problem until now - but...</font>

[8]> (cl-ppcre:scan "(a|)*" (target 100000))
*** - Lisp stack overflow. RESET

[9]> (cl-ppcre:scan "(a|)*" (target 3200))
*** - Lisp stack overflow. RESET
</pre>

<p>
With CMUCL the situation is better and worse at the same time. It will
take a lot longer until CMUCL gives up but if it gives up the whole
Lisp image will silently die (at least on my machine):
<p>
[Note: This was true for CMUCL&nbsp;18e - CMUCL&nbsp;19a behaves in a much nicer way and gives you a chance to recover.]

<pre>
* (defun target (n) (concatenate 'string (make-string n :initial-element #\a) "b"))
TARGET

* (cl-ppcre:scan "(a|)*" (target 3200))
0
3200
#(3200)
#(3200)

* (cl-ppcre:scan "(a|)*" (target 10000))
0
10000
#(10000)
#(10000)

* (cl-ppcre:scan "(a|)*" (target 100000))
0
100000
#(100000)
#(100000)

* (cl-ppcre:scan "(a|)*" (target 1000000))
0
1000000
#(1000000)
#(1000000)

<font color=orange>;; No problem until now - but...</font>

* (cl-ppcre:scan "(a|)*" (target 10000000))
edi@bird:~ &gt;
</pre>

This behaviour can be changed with <em>very</em> conservative optimization settings but that'll make CL-PPCRE crawl compared to Perl.

<p>
You might want to compare this to the way Perl handles the same situation. It might lie to you:

<pre>
edi@bird:~ > perl -le '$_="a" x 32766 . "b"; /(a|)*/; print $1'

edi@bird:~ > perl -le '$_="a" x 32767 . "b"; /(a|)*/; print $1'
a
</pre>

Or it might warn you before it's lying to you:
<pre>
edi@bird:~ > perl -lwe '$_="a" x 32767 . "b"; /(a|)*/; print $1'
Complex regular subexpression recursion limit (32766) exceeded at -e line 1.
a
</pre>

Or it might simply die:
<pre>
edi@bird:~ > /opt/perl-5.8/bin/perl -lwe '$_="a" x 32767 . "b"; /(a|)*/; print $1'
Segmentation fault
</pre>

Your mileage may vary, of course...

<h4><a name="quote" class=none><code>&quot;\Q&quot;</code> doesn't work, or does it?</a></h4>

In Perl the following code works as expected, i.e. it prints <code>1</code>.
<pre>
#!/usr/bin/perl -l

$a = '\E*';
print 1
  if '\E*\E*' =~ /(?:\Q$a\E){2}/;
</pre>

If you try to do something similar in CL-PPCRE you get an error:

<pre>
* (let ((cl-ppcre:*allow-quoting* t)
        (a &quot;\\E*&quot;))
    (cl-ppcre:scan (concatenate 'string &quot;(?:\\Q&quot; a &quot;\\E){2}&quot;) &quot;\\E*\\E*&quot;))
Quantifier '*' not allowed at position 3 in string &quot;(?:*\\E){2}&quot;
</pre>

The error message might give you a hint as to why this happens:
Because <a href="#*allow-quoting*"><code>*ALLOW-QUOTING*</code></a>
was <em>true</em> the concatenated string was pre-processed before it
was fed to CL-PPCRE's parser - the result of this pre-processing is
<code>&quot;(?:*\\E){2}&quot;</code> because the
<code>&quot;\\E&quot;</code> in the string <code>A</code> was taken to
be the end of the quoted section started by
<code>&quot;\\Q&quot;</code>. This cannot happen in Perl due to its
complicated interpolation rules - see <code>man&nbsp;perlop</code> for
the scary details. It <em>can</em> happen in CL-PPCRE, though.
Bummer!
<p>
What gives? <code>&quot;\\Q...\\E&quot;</code> in CL-PPCRE should only
be used in literal strings. If you want to quote arbitrary strings
try <a href="http://weitz.de/cl-interpol/">CL-INTERPOL</a> or use <a
href="#quote-meta-chars"><code>QUOTE-META-CHARS</code></a>:
<pre>
* (let ((a &quot;\\E*&quot;))
    (cl-ppcre:scan (concatenate 'string
                                &quot;(?:&quot; (cl-ppcre:quote-meta-chars a) &quot;){2}&quot;)
                   &quot;\\E*\\E*&quot;))
0
6
#()
#()
</pre>
Or, even better and Lisp-ier, use the <a href="#create-scanner2">S-expression syntax</a> instead - no need for quoting in this case:
<pre>
* (let ((a "\\E*"))
    (cl-ppcre:scan `(:greedy-repetition 2 2 ,a)
                   "\\E*\\E*"))
0
6
#()
#()
</pre>

<h4><a name="backslash" class=none>Backslashes may confuse you...</a></h4>

<pre>
* (let ((a &quot;y\\y&quot;))
    (cl-ppcre:scan a a))
NIL
</pre>

You didn't expect this to yield <code>NIL</code>, did you? Shouldn't something like <code>(CL-PPCRE:SCAN&nbsp;A&nbsp;A)</code> always return a true value? No, because the first and the second argument to <code>SCAN</code> are handled differently: The first argument is fed to CL-PPCRE's parser and is treated like a Perl regular expression. In particular, the parser "sees" <code>\y</code> and converts it to <code>y</code> because <code>\y</code> has no special meaning in regular expressions. So, the regular expression is the constant string <code>"yy"</code>. But the second argument isn't converted - it is left as is, i.e. it's equivalent to Perl's <code>'y\y'</code>. In other words, this example would be equivalent to the Perl code

<pre>
'y\y' =~ /y\y/;
</pre>

or to

<pre>
$a = 'y\y';
$a =~ /$a/;
</pre>

which should explain why it doesn't match.
<p>
Still confused? You might want to try <a href="http://weitz.de/cl-interpol/">CL-INTERPOL</a>.

<br>&nbsp;<br><h3><a class=none name="remarks">Remarks</a></h3>

The sample output from CMUCL and CLISP has been slightly edited to
increase readability.
<p>
All test cases and benchmarks in this document where performed on an
IBM Thinkpad T23 laptop (Pentium&nbsp;III 1.2&nbsp;GHz,
768&nbsp;MB&nbsp;RAM) running <a href="http://www.gentoo.org/">Gentoo
Linux</a> 1.1a.

<br>&nbsp;<br><h3><a class=none name="allegro">AllegroCL compatibility mode</a></h3>

Since autumn 2004 <a
href="http://www.franz.com/products/allegrocl/">AllegroCL</a> offers
<a
href="http://www.franz.com/support/documentation/7.0/doc/regexp.htm">a
new regular expression API</a> with a syntax very similar to
CL-PPCRE. Although CL-PPCRE is quite fast already, AllegroCL's engine will
most likely be even faster (but only on AllegroCL, of course).  However, you might want to
stick to CL-PPCRE because you have a "legacy" application or because
you want your code to be portable to other Lisp implementations.
Therefore, beginning from version 1.2.0, CL-PPCRE offers a
"compatibility mode" where you can continue using the CL-PPCRE API as
described <a href="#dict">above</a> but deploy the AllegroCL regex
engine under the hood. (The details are: Calls to <a
href="#create-scanner"><code>CREATE-SCANNER</code></a> and <a
href="#scan"><code>SCAN</code></a> are dispatched to their AllegroCL
counterparts <a
href="http://www.franz.com/support/documentation/7.0/doc/operators/excl/compile-re.htm"><code>EXCL:COMPILE-RE</code></a>
and <a
href="http://www.franz.com/support/documentation/7.0/doc/operators/excl/match-re.htm"><code>EXCL:MATCH-RE</code></a>
while everything else is left as is.)
<p>
The advantage of this mode is that you'll get a much smaller image and
most likely faster code. (But note that CL-PPCRE needs to do a small amount of work to massage AllegroCL's output into the format expected by CL-PPCRE.) The downside is that your code won't be
fully compatible with CL-PPCRE anymore. Here are some of the
differences (most of which probably don't matter very often):
<ul>
<li>The AllegroCL engine doesn't offer <a
href="#parse-tree-synonym">parse tree synonyms</a> and <a href="#filters">filters</a>.
<li>The AllegroCL engine <a href="http://www.franz.com/support/documentation/7.0/doc/regexp.htm#regexp-new-compatibility-2">will choke on some regular expressions involving curly braces</a> that are accepted by Perl and CL-PPCRE's native engine.
<li>The AllegroCL engine's case-folding mode switch (which is used instead of CL-PPCRE's <a href="#create-scanner"><code>:CASE-INSENSITIVE</code> keyword parameter</a>) <a href="http://www.franz.com/support/documentation/7.0/doc/regexp.htm#regexp-new-matching-2">is currently only effective for ASCII characters</a>.
<li>CL-PPCRE's engine doesn't understand the <a href="http://www.franz.com/support/documentation/7.0/doc/regexp.htm#regexp-new-capturing-2">named register groups</a> provided by AllegroCL.
<li>The AllegroCL engine <a href="http://www.franz.com/support/documentation/7.0/doc/regexp.htm#regexp-new-compatibility-2">doesn't support</a> <a href="#*allow-quoting*">quoting of metacharacters</a>.
<li>In AllegroCL compatibility mode compiled regular expressions (as returned by <a href="#create-scanner"><code>CREATE-SCANNER</code></a>) aren't functions but structures.
</ul>
For more details about the AllegroCL engine and possible deviations from CL-PPCRE see the <a href="http://www.franz.com/support/documentation/7.0/doc/regexp.htm">documentation</a> at the <a href="http://www.franz.com/">Franz Inc. website</a>.
<p>
To use the AllegroCL compatibility mode you have to
<pre>
(push :use-acl-regexp2-engine *features*)
</pre>
<em>before</em> you compile CL-PPCRE.

<br>&nbsp;<br><h3><a class=none name="ack">Acknowledgements</a></h3>

Although I didn't use their code I was heavily inspired by looking at
the Scheme/CL regex implementations of <a
href="http://www.ccs.neu.edu/home/dorai/pregexp/pregexp.html">Dorai
Sitaram</a> and <a
href="http://www.geocities.com/mparker762/clawk#regex">Michael
Parker</a>. Also, the nice folks from CMUCL's <a
href="http://www.cons.org/cmucl/support.html">mailing list</a> as well
as the output of Perl's <code>use re &quot;debug&quot;</code> pragma
have been very helpful in optimizing the scanners created by CL-PPCRE.

<p>
The asdf system definitions were kindly provided by Marco
Baringer. Hannu Koivisto provided patches to make the
<code>.system</code> files more usable.  Thanks to Kevin Rosenberg and
Douglas Crosher for pointing out how to be friendly to case-sensitive
ACL images. Thanks to Karsten Poeck and JP Massar for their help in
making CL-PPCRE work with Corman Lisp. JP Massar and Kent M. Pitman
also helped to improve/fix the test suite and the compiler macro.

<p>
Thanks to the guys at &quot;Caf&eacute; Ol&eacute;&quot; in Hamburg
where I wrote most of the code and thanks to my wife for lending me
her PowerBook to test CL-PPCRE with MCL and OpenMCL.

<p>
$Header: /usr/local/cvsrep/cl-ppcre/doc/index.html,v 1.113 2005/02/02 18:35:54 edi Exp $
<p><a href="http://weitz.de/index.html">BACK TO MY HOMEPAGE</a>

</body>
</html>